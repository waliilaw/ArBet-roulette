"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/arweave";
exports.ids = ["vendor-chunks/arweave"];
exports.modules = {

/***/ "(ssr)/./node_modules/arweave/node/ar.js":
/*!*****************************************!*\
  !*** ./node_modules/arweave/node/ar.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst bignumber_js_1 = __webpack_require__(/*! bignumber.js */ \"(ssr)/./node_modules/bignumber.js/bignumber.js\");\nclass Ar {\n    /**\n     * Method to take a string value and return a bignumber object.\n     *\n     * @protected\n     * @type {Function}\n     * @memberof Arweave\n     */\n    BigNum;\n    constructor() {\n        // Configure and assign the constructor function for the bignumber library.\n        this.BigNum = (value, decimals) => {\n            let instance = bignumber_js_1.BigNumber.clone({ DECIMAL_PLACES: decimals });\n            return new instance(value);\n        };\n    }\n    winstonToAr(winstonString, { formatted = false, decimals = 12, trim = true } = {}) {\n        let number = this.stringToBigNum(winstonString, decimals).shiftedBy(-12);\n        return formatted ? number.toFormat(decimals) : number.toFixed(decimals);\n    }\n    arToWinston(arString, { formatted = false } = {}) {\n        let number = this.stringToBigNum(arString).shiftedBy(12);\n        return formatted ? number.toFormat() : number.toFixed(0);\n    }\n    compare(winstonStringA, winstonStringB) {\n        let a = this.stringToBigNum(winstonStringA);\n        let b = this.stringToBigNum(winstonStringB);\n        return a.comparedTo(b);\n    }\n    isEqual(winstonStringA, winstonStringB) {\n        return this.compare(winstonStringA, winstonStringB) === 0;\n    }\n    isLessThan(winstonStringA, winstonStringB) {\n        let a = this.stringToBigNum(winstonStringA);\n        let b = this.stringToBigNum(winstonStringB);\n        return a.isLessThan(b);\n    }\n    isGreaterThan(winstonStringA, winstonStringB) {\n        let a = this.stringToBigNum(winstonStringA);\n        let b = this.stringToBigNum(winstonStringB);\n        return a.isGreaterThan(b);\n    }\n    add(winstonStringA, winstonStringB) {\n        let a = this.stringToBigNum(winstonStringA);\n        let b = this.stringToBigNum(winstonStringB);\n        return a.plus(winstonStringB).toFixed(0);\n    }\n    sub(winstonStringA, winstonStringB) {\n        let a = this.stringToBigNum(winstonStringA);\n        let b = this.stringToBigNum(winstonStringB);\n        return a.minus(winstonStringB).toFixed(0);\n    }\n    stringToBigNum(stringValue, decimalPlaces = 12) {\n        return this.BigNum(stringValue, decimalPlaces);\n    }\n}\nexports[\"default\"] = Ar;\n//# sourceMappingURL=ar.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2FyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixtQkFBTyxDQUFDLG9FQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDBCQUEwQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0RBQWdELElBQUk7QUFDckY7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQixJQUFJO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvd2FsaS9Eb3dubG9hZHMvcm91bGV0dGUgL25vZGVfbW9kdWxlcy9hcndlYXZlL25vZGUvYXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IHJlcXVpcmUoXCJiaWdudW1iZXIuanNcIik7XG5jbGFzcyBBciB7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHRha2UgYSBzdHJpbmcgdmFsdWUgYW5kIHJldHVybiBhIGJpZ251bWJlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBtZW1iZXJvZiBBcndlYXZlXG4gICAgICovXG4gICAgQmlnTnVtO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBDb25maWd1cmUgYW5kIGFzc2lnbiB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBiaWdudW1iZXIgbGlicmFyeS5cbiAgICAgICAgdGhpcy5CaWdOdW0gPSAodmFsdWUsIGRlY2ltYWxzKSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBiaWdudW1iZXJfanNfMS5CaWdOdW1iZXIuY2xvbmUoeyBERUNJTUFMX1BMQUNFUzogZGVjaW1hbHMgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGluc3RhbmNlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgd2luc3RvblRvQXIod2luc3RvblN0cmluZywgeyBmb3JtYXR0ZWQgPSBmYWxzZSwgZGVjaW1hbHMgPSAxMiwgdHJpbSA9IHRydWUgfSA9IHt9KSB7XG4gICAgICAgIGxldCBudW1iZXIgPSB0aGlzLnN0cmluZ1RvQmlnTnVtKHdpbnN0b25TdHJpbmcsIGRlY2ltYWxzKS5zaGlmdGVkQnkoLTEyKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZCA/IG51bWJlci50b0Zvcm1hdChkZWNpbWFscykgOiBudW1iZXIudG9GaXhlZChkZWNpbWFscyk7XG4gICAgfVxuICAgIGFyVG9XaW5zdG9uKGFyU3RyaW5nLCB7IGZvcm1hdHRlZCA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBsZXQgbnVtYmVyID0gdGhpcy5zdHJpbmdUb0JpZ051bShhclN0cmluZykuc2hpZnRlZEJ5KDEyKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZCA/IG51bWJlci50b0Zvcm1hdCgpIDogbnVtYmVyLnRvRml4ZWQoMCk7XG4gICAgfVxuICAgIGNvbXBhcmUod2luc3RvblN0cmluZ0EsIHdpbnN0b25TdHJpbmdCKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5zdHJpbmdUb0JpZ051bSh3aW5zdG9uU3RyaW5nQSk7XG4gICAgICAgIGxldCBiID0gdGhpcy5zdHJpbmdUb0JpZ051bSh3aW5zdG9uU3RyaW5nQik7XG4gICAgICAgIHJldHVybiBhLmNvbXBhcmVkVG8oYik7XG4gICAgfVxuICAgIGlzRXF1YWwod2luc3RvblN0cmluZ0EsIHdpbnN0b25TdHJpbmdCKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUod2luc3RvblN0cmluZ0EsIHdpbnN0b25TdHJpbmdCKSA9PT0gMDtcbiAgICB9XG4gICAgaXNMZXNzVGhhbih3aW5zdG9uU3RyaW5nQSwgd2luc3RvblN0cmluZ0IpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLnN0cmluZ1RvQmlnTnVtKHdpbnN0b25TdHJpbmdBKTtcbiAgICAgICAgbGV0IGIgPSB0aGlzLnN0cmluZ1RvQmlnTnVtKHdpbnN0b25TdHJpbmdCKTtcbiAgICAgICAgcmV0dXJuIGEuaXNMZXNzVGhhbihiKTtcbiAgICB9XG4gICAgaXNHcmVhdGVyVGhhbih3aW5zdG9uU3RyaW5nQSwgd2luc3RvblN0cmluZ0IpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLnN0cmluZ1RvQmlnTnVtKHdpbnN0b25TdHJpbmdBKTtcbiAgICAgICAgbGV0IGIgPSB0aGlzLnN0cmluZ1RvQmlnTnVtKHdpbnN0b25TdHJpbmdCKTtcbiAgICAgICAgcmV0dXJuIGEuaXNHcmVhdGVyVGhhbihiKTtcbiAgICB9XG4gICAgYWRkKHdpbnN0b25TdHJpbmdBLCB3aW5zdG9uU3RyaW5nQikge1xuICAgICAgICBsZXQgYSA9IHRoaXMuc3RyaW5nVG9CaWdOdW0od2luc3RvblN0cmluZ0EpO1xuICAgICAgICBsZXQgYiA9IHRoaXMuc3RyaW5nVG9CaWdOdW0od2luc3RvblN0cmluZ0IpO1xuICAgICAgICByZXR1cm4gYS5wbHVzKHdpbnN0b25TdHJpbmdCKS50b0ZpeGVkKDApO1xuICAgIH1cbiAgICBzdWIod2luc3RvblN0cmluZ0EsIHdpbnN0b25TdHJpbmdCKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5zdHJpbmdUb0JpZ051bSh3aW5zdG9uU3RyaW5nQSk7XG4gICAgICAgIGxldCBiID0gdGhpcy5zdHJpbmdUb0JpZ051bSh3aW5zdG9uU3RyaW5nQik7XG4gICAgICAgIHJldHVybiBhLm1pbnVzKHdpbnN0b25TdHJpbmdCKS50b0ZpeGVkKDApO1xuICAgIH1cbiAgICBzdHJpbmdUb0JpZ051bShzdHJpbmdWYWx1ZSwgZGVjaW1hbFBsYWNlcyA9IDEyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkJpZ051bShzdHJpbmdWYWx1ZSwgZGVjaW1hbFBsYWNlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/ar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/blocks.js":
/*!*********************************************!*\
  !*** ./node_modules/arweave/node/blocks.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst error_1 = __importDefault(__webpack_require__(/*! ./lib/error */ \"(ssr)/./node_modules/arweave/node/lib/error.js\"));\n__webpack_require__(/*! arconnect */ \"(ssr)/./node_modules/arconnect/index.es.js\");\nclass Blocks {\n    api;\n    network;\n    static HASH_ENDPOINT = \"block/hash/\";\n    static HEIGHT_ENDPOINT = \"block/height/\";\n    constructor(api, network) {\n        this.api = api;\n        this.network = network;\n    }\n    /**\n     * Gets a block by its \"indep_hash\"\n     */\n    async get(indepHash) {\n        const response = await this.api.get(`${Blocks.HASH_ENDPOINT}${indepHash}`);\n        if (response.status === 200) {\n            return response.data;\n        }\n        else {\n            if (response.status === 404) {\n                throw new error_1.default(\"BLOCK_NOT_FOUND\" /* ArweaveErrorType.BLOCK_NOT_FOUND */);\n            }\n            else {\n                throw new Error(`Error while loading block data: ${response}`);\n            }\n        }\n    }\n    /**\n     * Gets a block by its \"height\"\n     */\n    async getByHeight(height) {\n        const response = await this.api.get(`${Blocks.HEIGHT_ENDPOINT}${height}`);\n        if (response.status === 200) {\n            return response.data;\n        }\n        else {\n            if (response.status === 404) {\n                throw new error_1.default(\"BLOCK_NOT_FOUND\" /* ArweaveErrorType.BLOCK_NOT_FOUND */);\n            }\n            else {\n                throw new Error(`Error while loading block data: ${response}`);\n            }\n        }\n    }\n    /**\n     * Gets current block data (ie. block with indep_hash = Network.getInfo().current)\n     */\n    async getCurrent() {\n        const { current } = await this.network.getInfo();\n        return await this.get(current);\n    }\n}\nexports[\"default\"] = Blocks;\n//# sourceMappingURL=blocks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2Jsb2Nrcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxtQkFBTyxDQUFDLG1FQUFhO0FBQ3JELG1CQUFPLENBQUMsNkRBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUJBQXFCLEVBQUUsVUFBVTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFNBQVM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsdUJBQXVCLEVBQUUsT0FBTztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFNBQVM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvd2FsaS9Eb3dubG9hZHMvcm91bGV0dGUgL25vZGVfbW9kdWxlcy9hcndlYXZlL25vZGUvYmxvY2tzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXJyb3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9saWIvZXJyb3JcIikpO1xucmVxdWlyZShcImFyY29ubmVjdFwiKTtcbmNsYXNzIEJsb2NrcyB7XG4gICAgYXBpO1xuICAgIG5ldHdvcms7XG4gICAgc3RhdGljIEhBU0hfRU5EUE9JTlQgPSBcImJsb2NrL2hhc2gvXCI7XG4gICAgc3RhdGljIEhFSUdIVF9FTkRQT0lOVCA9IFwiYmxvY2svaGVpZ2h0L1wiO1xuICAgIGNvbnN0cnVjdG9yKGFwaSwgbmV0d29yaykge1xuICAgICAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICAgICAgdGhpcy5uZXR3b3JrID0gbmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJsb2NrIGJ5IGl0cyBcImluZGVwX2hhc2hcIlxuICAgICAqL1xuICAgIGFzeW5jIGdldChpbmRlcEhhc2gpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaS5nZXQoYCR7QmxvY2tzLkhBU0hfRU5EUE9JTlR9JHtpbmRlcEhhc2h9YCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5kZWZhdWx0KFwiQkxPQ0tfTk9UX0ZPVU5EXCIgLyogQXJ3ZWF2ZUVycm9yVHlwZS5CTE9DS19OT1RfRk9VTkQgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBsb2FkaW5nIGJsb2NrIGRhdGE6ICR7cmVzcG9uc2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGJsb2NrIGJ5IGl0cyBcImhlaWdodFwiXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QnlIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGkuZ2V0KGAke0Jsb2Nrcy5IRUlHSFRfRU5EUE9JTlR9JHtoZWlnaHR9YCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5kZWZhdWx0KFwiQkxPQ0tfTk9UX0ZPVU5EXCIgLyogQXJ3ZWF2ZUVycm9yVHlwZS5CTE9DS19OT1RfRk9VTkQgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBsb2FkaW5nIGJsb2NrIGRhdGE6ICR7cmVzcG9uc2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjdXJyZW50IGJsb2NrIGRhdGEgKGllLiBibG9jayB3aXRoIGluZGVwX2hhc2ggPSBOZXR3b3JrLmdldEluZm8oKS5jdXJyZW50KVxuICAgICAqL1xuICAgIGFzeW5jIGdldEN1cnJlbnQoKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gYXdhaXQgdGhpcy5uZXR3b3JrLmdldEluZm8oKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0KGN1cnJlbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2Nrcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2Nrcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/blocks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/chunks.js":
/*!*********************************************!*\
  !*** ./node_modules/arweave/node/chunks.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst error_1 = __webpack_require__(/*! ./lib/error */ \"(ssr)/./node_modules/arweave/node/lib/error.js\");\nconst ArweaveUtils = __importStar(__webpack_require__(/*! ./lib/utils */ \"(ssr)/./node_modules/arweave/node/lib/utils.js\"));\nclass Chunks {\n    api;\n    constructor(api) {\n        this.api = api;\n    }\n    async getTransactionOffset(id) {\n        const resp = await this.api.get(`tx/${id}/offset`);\n        if (resp.status === 200) {\n            return resp.data;\n        }\n        throw new Error(`Unable to get transaction offset: ${(0, error_1.getError)(resp)}`);\n    }\n    async getChunk(offset) {\n        const resp = await this.api.get(`chunk/${offset}`);\n        if (resp.status === 200) {\n            return resp.data;\n        }\n        throw new Error(`Unable to get chunk: ${(0, error_1.getError)(resp)}`);\n    }\n    async getChunkData(offset) {\n        const chunk = await this.getChunk(offset);\n        const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);\n        return buf;\n    }\n    firstChunkOffset(offsetResponse) {\n        return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;\n    }\n    async downloadChunkedData(id) {\n        const offsetResponse = await this.getTransactionOffset(id);\n        const size = parseInt(offsetResponse.size);\n        const endOffset = parseInt(offsetResponse.offset);\n        const startOffset = endOffset - size + 1;\n        const data = new Uint8Array(size);\n        let byte = 0;\n        while (byte < size) {\n            if (this.api.config.logging) {\n                console.log(`[chunk] ${byte}/${size}`);\n            }\n            let chunkData;\n            try {\n                chunkData = await this.getChunkData(startOffset + byte);\n            }\n            catch (error) {\n                console.error(`[chunk] Failed to fetch chunk at offset ${startOffset + byte}`);\n                console.error(`[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node`);\n            }\n            if (chunkData) {\n                data.set(chunkData, byte);\n                byte += chunkData.length;\n            }\n            else {\n                throw new Error(`Couldn't complete data download at ${byte}/${size}`);\n            }\n        }\n        return data;\n    }\n}\nexports[\"default\"] = Chunks;\n//# sourceMappingURL=chunks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2NodW5rcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQWE7QUFDckMsa0NBQWtDLG1CQUFPLENBQUMsbUVBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEdBQUc7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDRCQUE0QjtBQUN6RjtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRCQUE0QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSyxHQUFHLEtBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLG1CQUFtQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxLQUFLLEdBQUcsS0FBSztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbGkvRG93bmxvYWRzL3JvdWxldHRlIC9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2NodW5rcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2xpYi9lcnJvclwiKTtcbmNvbnN0IEFyd2VhdmVVdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvdXRpbHNcIikpO1xuY2xhc3MgQ2h1bmtzIHtcbiAgICBhcGk7XG4gICAgY29uc3RydWN0b3IoYXBpKSB7XG4gICAgICAgIHRoaXMuYXBpID0gYXBpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2FjdGlvbk9mZnNldChpZCkge1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5hcGkuZ2V0KGB0eC8ke2lkfS9vZmZzZXRgKTtcbiAgICAgICAgaWYgKHJlc3Auc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZ2V0IHRyYW5zYWN0aW9uIG9mZnNldDogJHsoMCwgZXJyb3JfMS5nZXRFcnJvcikocmVzcCl9YCk7XG4gICAgfVxuICAgIGFzeW5jIGdldENodW5rKG9mZnNldCkge1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5hcGkuZ2V0KGBjaHVuay8ke29mZnNldH1gKTtcbiAgICAgICAgaWYgKHJlc3Auc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZ2V0IGNodW5rOiAkeygwLCBlcnJvcl8xLmdldEVycm9yKShyZXNwKX1gKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2h1bmtEYXRhKG9mZnNldCkge1xuICAgICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHRoaXMuZ2V0Q2h1bmsob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgYnVmID0gQXJ3ZWF2ZVV0aWxzLmI2NFVybFRvQnVmZmVyKGNodW5rLmNodW5rKTtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZmlyc3RDaHVua09mZnNldChvZmZzZXRSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQob2Zmc2V0UmVzcG9uc2Uub2Zmc2V0KSAtIHBhcnNlSW50KG9mZnNldFJlc3BvbnNlLnNpemUpICsgMTtcbiAgICB9XG4gICAgYXN5bmMgZG93bmxvYWRDaHVua2VkRGF0YShpZCkge1xuICAgICAgICBjb25zdCBvZmZzZXRSZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25PZmZzZXQoaWQpO1xuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VJbnQob2Zmc2V0UmVzcG9uc2Uuc2l6ZSk7XG4gICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHBhcnNlSW50KG9mZnNldFJlc3BvbnNlLm9mZnNldCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gZW5kT2Zmc2V0IC0gc2l6ZSArIDE7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgbGV0IGJ5dGUgPSAwO1xuICAgICAgICB3aGlsZSAoYnl0ZSA8IHNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaS5jb25maWcubG9nZ2luZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbY2h1bmtdICR7Ynl0ZX0vJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNodW5rRGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2h1bmtEYXRhID0gYXdhaXQgdGhpcy5nZXRDaHVua0RhdGEoc3RhcnRPZmZzZXQgKyBieXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtjaHVua10gRmFpbGVkIHRvIGZldGNoIGNodW5rIGF0IG9mZnNldCAke3N0YXJ0T2Zmc2V0ICsgYnl0ZX1gKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbY2h1bmtdIFRoaXMgY291bGQgaW5kaWNhdGUgdGhhdCB0aGUgY2h1bmsgd2Fzbid0IHVwbG9hZGVkIG9yIGhhc24ndCB5ZXQgc2VlZGVkIHByb3Blcmx5IHRvIGEgcGFydGljdWxhciBnYXRld2F5L25vZGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaHVua0RhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnNldChjaHVua0RhdGEsIGJ5dGUpO1xuICAgICAgICAgICAgICAgIGJ5dGUgKz0gY2h1bmtEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgY29tcGxldGUgZGF0YSBkb3dubG9hZCBhdCAke2J5dGV9LyR7c2l6ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDaHVua3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVua3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/chunks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/common.js":
/*!*********************************************!*\
  !*** ./node_modules/arweave/node/common.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ar_1 = __importDefault(__webpack_require__(/*! ./ar */ \"(ssr)/./node_modules/arweave/node/ar.js\"));\nconst api_1 = __importDefault(__webpack_require__(/*! ./lib/api */ \"(ssr)/./node_modules/arweave/node/lib/api.js\"));\nconst node_driver_1 = __importDefault(__webpack_require__(/*! ./lib/crypto/node-driver */ \"(ssr)/./node_modules/arweave/node/lib/crypto/node-driver.js\"));\nconst network_1 = __importDefault(__webpack_require__(/*! ./network */ \"(ssr)/./node_modules/arweave/node/network.js\"));\nconst transactions_1 = __importDefault(__webpack_require__(/*! ./transactions */ \"(ssr)/./node_modules/arweave/node/transactions.js\"));\nconst wallets_1 = __importDefault(__webpack_require__(/*! ./wallets */ \"(ssr)/./node_modules/arweave/node/wallets.js\"));\nconst transaction_1 = __importDefault(__webpack_require__(/*! ./lib/transaction */ \"(ssr)/./node_modules/arweave/node/lib/transaction.js\"));\nconst ArweaveUtils = __importStar(__webpack_require__(/*! ./lib/utils */ \"(ssr)/./node_modules/arweave/node/lib/utils.js\"));\nconst silo_1 = __importDefault(__webpack_require__(/*! ./silo */ \"(ssr)/./node_modules/arweave/node/silo.js\"));\nconst chunks_1 = __importDefault(__webpack_require__(/*! ./chunks */ \"(ssr)/./node_modules/arweave/node/chunks.js\"));\nconst blocks_1 = __importDefault(__webpack_require__(/*! ./blocks */ \"(ssr)/./node_modules/arweave/node/blocks.js\"));\nclass Arweave {\n    api;\n    wallets;\n    transactions;\n    network;\n    blocks;\n    ar;\n    silo;\n    chunks;\n    static init;\n    static crypto = new node_driver_1.default();\n    static utils = ArweaveUtils;\n    constructor(apiConfig) {\n        this.api = new api_1.default(apiConfig);\n        this.wallets = new wallets_1.default(this.api, Arweave.crypto);\n        this.chunks = new chunks_1.default(this.api);\n        this.transactions = new transactions_1.default(this.api, Arweave.crypto, this.chunks);\n        this.silo = new silo_1.default(this.api, this.crypto, this.transactions);\n        this.network = new network_1.default(this.api);\n        this.blocks = new blocks_1.default(this.api, this.network);\n        this.ar = new ar_1.default();\n    }\n    /** @deprecated */\n    get crypto() {\n        return Arweave.crypto;\n    }\n    /** @deprecated */\n    get utils() {\n        return Arweave.utils;\n    }\n    getConfig() {\n        return {\n            api: this.api.getConfig(),\n            crypto: null,\n        };\n    }\n    async createTransaction(attributes, jwk) {\n        const transaction = {};\n        Object.assign(transaction, attributes);\n        if (!attributes.data && !(attributes.target && attributes.quantity)) {\n            throw new Error(`A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.`);\n        }\n        if (attributes.owner == undefined) {\n            if (jwk && jwk !== \"use_wallet\") {\n                transaction.owner = jwk.n;\n            }\n        }\n        if (attributes.last_tx == undefined) {\n            transaction.last_tx = await this.transactions.getTransactionAnchor();\n        }\n        if (typeof attributes.data === \"string\") {\n            attributes.data = ArweaveUtils.stringToBuffer(attributes.data);\n        }\n        if (attributes.data instanceof ArrayBuffer) {\n            attributes.data = new Uint8Array(attributes.data);\n        }\n        if (attributes.data && !(attributes.data instanceof Uint8Array)) {\n            throw new Error(\"Expected data to be a string, Uint8Array or ArrayBuffer\");\n        }\n        if (attributes.reward == undefined) {\n            const length = attributes.data ? attributes.data.byteLength : 0;\n            transaction.reward = await this.transactions.getPrice(length, transaction.target);\n        }\n        // here we should call prepare chunk\n        transaction.data_root = \"\";\n        transaction.data_size = attributes.data\n            ? attributes.data.byteLength.toString()\n            : \"0\";\n        transaction.data = attributes.data || new Uint8Array(0);\n        const createdTransaction = new transaction_1.default(transaction);\n        await createdTransaction.getSignatureData();\n        return createdTransaction;\n    }\n    async createSiloTransaction(attributes, jwk, siloUri) {\n        const transaction = {};\n        Object.assign(transaction, attributes);\n        if (!attributes.data) {\n            throw new Error(`Silo transactions must have a 'data' value`);\n        }\n        if (!siloUri) {\n            throw new Error(`No Silo URI specified.`);\n        }\n        if (attributes.target || attributes.quantity) {\n            throw new Error(`Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.`);\n        }\n        if (attributes.owner == undefined) {\n            if (!jwk || !jwk.n) {\n                throw new Error(`A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.`);\n            }\n            transaction.owner = jwk.n;\n        }\n        if (attributes.last_tx == undefined) {\n            transaction.last_tx = await this.transactions.getTransactionAnchor();\n        }\n        const siloResource = await this.silo.parseUri(siloUri);\n        if (typeof attributes.data == \"string\") {\n            const encrypted = await this.crypto.encrypt(ArweaveUtils.stringToBuffer(attributes.data), siloResource.getEncryptionKey());\n            transaction.reward = await this.transactions.getPrice(encrypted.byteLength);\n            transaction.data = ArweaveUtils.bufferTob64Url(encrypted);\n        }\n        if (attributes.data instanceof Uint8Array) {\n            const encrypted = await this.crypto.encrypt(attributes.data, siloResource.getEncryptionKey());\n            transaction.reward = await this.transactions.getPrice(encrypted.byteLength);\n            transaction.data = ArweaveUtils.bufferTob64Url(encrypted);\n        }\n        const siloTransaction = new transaction_1.default(transaction);\n        siloTransaction.addTag(\"Silo-Name\", siloResource.getAccessKey());\n        siloTransaction.addTag(\"Silo-Version\", `0.1.0`);\n        return siloTransaction;\n    }\n    arql(query) {\n        return this.api\n            .post(\"/arql\", query)\n            .then((response) => response.data || []);\n    }\n}\nexports[\"default\"] = Arweave;\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsbUJBQU8sQ0FBQyxxREFBTTtBQUMzQyw4QkFBOEIsbUJBQU8sQ0FBQywrREFBVztBQUNqRCxzQ0FBc0MsbUJBQU8sQ0FBQyw2RkFBMEI7QUFDeEUsa0NBQWtDLG1CQUFPLENBQUMsK0RBQVc7QUFDckQsdUNBQXVDLG1CQUFPLENBQUMseUVBQWdCO0FBQy9ELGtDQUFrQyxtQkFBTyxDQUFDLCtEQUFXO0FBQ3JELHNDQUFzQyxtQkFBTyxDQUFDLCtFQUFtQjtBQUNqRSxrQ0FBa0MsbUJBQU8sQ0FBQyxtRUFBYTtBQUN2RCwrQkFBK0IsbUJBQU8sQ0FBQyx5REFBUTtBQUMvQyxpQ0FBaUMsbUJBQU8sQ0FBQyw2REFBVTtBQUNuRCxpQ0FBaUMsbUJBQU8sQ0FBQyw2REFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbGkvRG93bmxvYWRzL3JvdWxldHRlIC9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2NvbW1vbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hclwiKSk7XG5jb25zdCBhcGlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9saWIvYXBpXCIpKTtcbmNvbnN0IG5vZGVfZHJpdmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGliL2NyeXB0by9ub2RlLWRyaXZlclwiKSk7XG5jb25zdCBuZXR3b3JrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbmV0d29ya1wiKSk7XG5jb25zdCB0cmFuc2FjdGlvbnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvbnNcIikpO1xuY29uc3Qgd2FsbGV0c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3dhbGxldHNcIikpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdHJhbnNhY3Rpb25cIikpO1xuY29uc3QgQXJ3ZWF2ZVV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi91dGlsc1wiKSk7XG5jb25zdCBzaWxvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2lsb1wiKSk7XG5jb25zdCBjaHVua3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jaHVua3NcIikpO1xuY29uc3QgYmxvY2tzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYmxvY2tzXCIpKTtcbmNsYXNzIEFyd2VhdmUge1xuICAgIGFwaTtcbiAgICB3YWxsZXRzO1xuICAgIHRyYW5zYWN0aW9ucztcbiAgICBuZXR3b3JrO1xuICAgIGJsb2NrcztcbiAgICBhcjtcbiAgICBzaWxvO1xuICAgIGNodW5rcztcbiAgICBzdGF0aWMgaW5pdDtcbiAgICBzdGF0aWMgY3J5cHRvID0gbmV3IG5vZGVfZHJpdmVyXzEuZGVmYXVsdCgpO1xuICAgIHN0YXRpYyB1dGlscyA9IEFyd2VhdmVVdGlscztcbiAgICBjb25zdHJ1Y3RvcihhcGlDb25maWcpIHtcbiAgICAgICAgdGhpcy5hcGkgPSBuZXcgYXBpXzEuZGVmYXVsdChhcGlDb25maWcpO1xuICAgICAgICB0aGlzLndhbGxldHMgPSBuZXcgd2FsbGV0c18xLmRlZmF1bHQodGhpcy5hcGksIEFyd2VhdmUuY3J5cHRvKTtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBuZXcgY2h1bmtzXzEuZGVmYXVsdCh0aGlzLmFwaSk7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gbmV3IHRyYW5zYWN0aW9uc18xLmRlZmF1bHQodGhpcy5hcGksIEFyd2VhdmUuY3J5cHRvLCB0aGlzLmNodW5rcyk7XG4gICAgICAgIHRoaXMuc2lsbyA9IG5ldyBzaWxvXzEuZGVmYXVsdCh0aGlzLmFwaSwgdGhpcy5jcnlwdG8sIHRoaXMudHJhbnNhY3Rpb25zKTtcbiAgICAgICAgdGhpcy5uZXR3b3JrID0gbmV3IG5ldHdvcmtfMS5kZWZhdWx0KHRoaXMuYXBpKTtcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBuZXcgYmxvY2tzXzEuZGVmYXVsdCh0aGlzLmFwaSwgdGhpcy5uZXR3b3JrKTtcbiAgICAgICAgdGhpcy5hciA9IG5ldyBhcl8xLmRlZmF1bHQoKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgZ2V0IGNyeXB0bygpIHtcbiAgICAgICAgcmV0dXJuIEFyd2VhdmUuY3J5cHRvO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBnZXQgdXRpbHMoKSB7XG4gICAgICAgIHJldHVybiBBcndlYXZlLnV0aWxzO1xuICAgIH1cbiAgICBnZXRDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcGk6IHRoaXMuYXBpLmdldENvbmZpZygpLFxuICAgICAgICAgICAgY3J5cHRvOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVUcmFuc2FjdGlvbihhdHRyaWJ1dGVzLCBqd2spIHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7fTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0cmFuc2FjdGlvbiwgYXR0cmlidXRlcyk7XG4gICAgICAgIGlmICghYXR0cmlidXRlcy5kYXRhICYmICEoYXR0cmlidXRlcy50YXJnZXQgJiYgYXR0cmlidXRlcy5xdWFudGl0eSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBuZXcgQXJ3ZWF2ZSB0cmFuc2FjdGlvbiBtdXN0IGhhdmUgYSAnZGF0YScgdmFsdWUsIG9yICd0YXJnZXQnIGFuZCAncXVhbnRpdHknIHZhbHVlcy5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcy5vd25lciA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChqd2sgJiYgandrICE9PSBcInVzZV93YWxsZXRcIikge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm93bmVyID0gandrLm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMubGFzdF90eCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmxhc3RfdHggPSBhd2FpdCB0aGlzLnRyYW5zYWN0aW9ucy5nZXRUcmFuc2FjdGlvbkFuY2hvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmRhdGEgPSBBcndlYXZlVXRpbHMuc3RyaW5nVG9CdWZmZXIoYXR0cmlidXRlcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcy5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KGF0dHJpYnV0ZXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuZGF0YSAmJiAhKGF0dHJpYnV0ZXMuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBkYXRhIHRvIGJlIGEgc3RyaW5nLCBVaW50OEFycmF5IG9yIEFycmF5QnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLnJld2FyZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGF0dHJpYnV0ZXMuZGF0YSA/IGF0dHJpYnV0ZXMuZGF0YS5ieXRlTGVuZ3RoIDogMDtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJld2FyZCA9IGF3YWl0IHRoaXMudHJhbnNhY3Rpb25zLmdldFByaWNlKGxlbmd0aCwgdHJhbnNhY3Rpb24udGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoZXJlIHdlIHNob3VsZCBjYWxsIHByZXBhcmUgY2h1bmtcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YV9yb290ID0gXCJcIjtcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YV9zaXplID0gYXR0cmlidXRlcy5kYXRhXG4gICAgICAgICAgICA/IGF0dHJpYnV0ZXMuZGF0YS5ieXRlTGVuZ3RoLnRvU3RyaW5nKClcbiAgICAgICAgICAgIDogXCIwXCI7XG4gICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSBhdHRyaWJ1dGVzLmRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRUcmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLmRlZmF1bHQodHJhbnNhY3Rpb24pO1xuICAgICAgICBhd2FpdCBjcmVhdGVkVHJhbnNhY3Rpb24uZ2V0U2lnbmF0dXJlRGF0YSgpO1xuICAgICAgICByZXR1cm4gY3JlYXRlZFRyYW5zYWN0aW9uO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVTaWxvVHJhbnNhY3Rpb24oYXR0cmlidXRlcywgandrLCBzaWxvVXJpKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge307XG4gICAgICAgIE9iamVjdC5hc3NpZ24odHJhbnNhY3Rpb24sIGF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWxvIHRyYW5zYWN0aW9ucyBtdXN0IGhhdmUgYSAnZGF0YScgdmFsdWVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNpbG9VcmkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gU2lsbyBVUkkgc3BlY2lmaWVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLnRhcmdldCB8fCBhdHRyaWJ1dGVzLnF1YW50aXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpbG8gdHJhbnNhY3Rpb25zIGNhbiBvbmx5IGJlIHVzZWQgZm9yIHN0b3JpbmcgZGF0YSwgc2VuZGluZyBBUiB0byBvdGhlciB3YWxsZXRzIGlzbid0IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcy5vd25lciA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghandrIHx8ICFqd2subikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBuZXcgQXJ3ZWF2ZSB0cmFuc2FjdGlvbiBtdXN0IGVpdGhlciBoYXZlIGFuICdvd25lcicgYXR0cmlidXRlLCBvciB5b3UgbXVzdCBwcm92aWRlIHRoZSBqd2sgcGFyYW1ldGVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub3duZXIgPSBqd2subjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcy5sYXN0X3R4ID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24ubGFzdF90eCA9IGF3YWl0IHRoaXMudHJhbnNhY3Rpb25zLmdldFRyYW5zYWN0aW9uQW5jaG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lsb1Jlc291cmNlID0gYXdhaXQgdGhpcy5zaWxvLnBhcnNlVXJpKHNpbG9VcmkpO1xuICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuZGF0YSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSBhd2FpdCB0aGlzLmNyeXB0by5lbmNyeXB0KEFyd2VhdmVVdGlscy5zdHJpbmdUb0J1ZmZlcihhdHRyaWJ1dGVzLmRhdGEpLCBzaWxvUmVzb3VyY2UuZ2V0RW5jcnlwdGlvbktleSgpKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJld2FyZCA9IGF3YWl0IHRoaXMudHJhbnNhY3Rpb25zLmdldFByaWNlKGVuY3J5cHRlZC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSBBcndlYXZlVXRpbHMuYnVmZmVyVG9iNjRVcmwoZW5jcnlwdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcy5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgZW5jcnlwdGVkID0gYXdhaXQgdGhpcy5jcnlwdG8uZW5jcnlwdChhdHRyaWJ1dGVzLmRhdGEsIHNpbG9SZXNvdXJjZS5nZXRFbmNyeXB0aW9uS2V5KCkpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmV3YXJkID0gYXdhaXQgdGhpcy50cmFuc2FjdGlvbnMuZ2V0UHJpY2UoZW5jcnlwdGVkLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IEFyd2VhdmVVdGlscy5idWZmZXJUb2I2NFVybChlbmNyeXB0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpbG9UcmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLmRlZmF1bHQodHJhbnNhY3Rpb24pO1xuICAgICAgICBzaWxvVHJhbnNhY3Rpb24uYWRkVGFnKFwiU2lsby1OYW1lXCIsIHNpbG9SZXNvdXJjZS5nZXRBY2Nlc3NLZXkoKSk7XG4gICAgICAgIHNpbG9UcmFuc2FjdGlvbi5hZGRUYWcoXCJTaWxvLVZlcnNpb25cIiwgYDAuMS4wYCk7XG4gICAgICAgIHJldHVybiBzaWxvVHJhbnNhY3Rpb247XG4gICAgfVxuICAgIGFycWwocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpXG4gICAgICAgICAgICAucG9zdChcIi9hcnFsXCIsIHF1ZXJ5KVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5kYXRhIHx8IFtdKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBcndlYXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/index.js":
/*!********************************************!*\
  !*** ./node_modules/arweave/node/index.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst common_1 = __importDefault(__webpack_require__(/*! ./common */ \"(ssr)/./node_modules/arweave/node/common.js\"));\ncommon_1.default.init = function (apiConfig = {}) {\n    return new common_1.default(apiConfig);\n};\nmodule.exports = common_1.default;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxpQ0FBaUMsbUJBQU8sQ0FBQyw2REFBVTtBQUNuRCxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YWxpL0Rvd25sb2Fkcy9yb3VsZXR0ZSAvbm9kZV9tb2R1bGVzL2Fyd2VhdmUvbm9kZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmNvbnN0IGNvbW1vbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1vblwiKSk7XG5jb21tb25fMS5kZWZhdWx0LmluaXQgPSBmdW5jdGlvbiAoYXBpQ29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gbmV3IGNvbW1vbl8xLmRlZmF1bHQoYXBpQ29uZmlnKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGNvbW1vbl8xLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/lib/api.js":
/*!**********************************************!*\
  !*** ./node_modules/arweave/node/lib/api.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Api {\n    METHOD_GET = \"GET\";\n    METHOD_POST = \"POST\";\n    config;\n    constructor(config) {\n        this.applyConfig(config);\n    }\n    applyConfig(config) {\n        this.config = this.mergeDefaults(config);\n    }\n    getConfig() {\n        return this.config;\n    }\n    mergeDefaults(config) {\n        const protocol = config.protocol || \"http\";\n        const port = config.port || (protocol === \"https\" ? 443 : 80);\n        return {\n            host: config.host || \"127.0.0.1\",\n            protocol,\n            port,\n            timeout: config.timeout || 20000,\n            logging: config.logging || false,\n            logger: config.logger || console.log,\n            network: config.network,\n        };\n    }\n    async get(endpoint, config) {\n        return await this.request(endpoint, { ...config, method: this.METHOD_GET });\n    }\n    async post(endpoint, body, config) {\n        const headers = new Headers(config?.headers || {});\n        if (!headers.get(\"content-type\")?.includes(\"application/json\")) {\n            headers.append(\"content-type\", \"application/json\");\n        }\n        headers.append(\"accept\", \"application/json, text/plain, */*\");\n        return await this.request(endpoint, {\n            ...config,\n            method: this.METHOD_POST,\n            body: typeof body !== \"string\" ? JSON.stringify(body) : body,\n            headers,\n        });\n    }\n    async request(endpoint, init) {\n        const headers = new Headers(init?.headers || {});\n        const baseURL = `${this.config.protocol}://${this.config.host}:${this.config.port}`;\n        /* responseType is purely for backwards compatibility with external apps */\n        const responseType = init?.responseType;\n        delete init?.responseType;\n        if (endpoint.startsWith(\"/\")) {\n            endpoint = endpoint.slice(1);\n        }\n        if (this.config.network) {\n            headers.append(\"x-network\", this.config.network);\n        }\n        if (this.config.logging) {\n            this.config.logger(`Requesting: ${baseURL}/${endpoint}`);\n        }\n        let res = await fetch(`${baseURL}/${endpoint}`, {\n            ...(init || {}),\n            headers,\n        });\n        if (this.config.logging) {\n            this.config.logger(`Response:   ${res.url} - ${res.status}`);\n        }\n        const contentType = res.headers.get(\"content-type\");\n        const charset = contentType?.match(/charset=([^()<>@,;:\\\"/[\\]?.=\\s]*)/i)?.[1];\n        const response = res;\n        const decodeText = async () => {\n            if (charset) {\n                try {\n                    response.data = new TextDecoder(charset).decode(await res.arrayBuffer());\n                }\n                catch (e) {\n                    response.data = (await res.text());\n                }\n            }\n            else {\n                response.data = (await res.text());\n            }\n        };\n        if (responseType === \"arraybuffer\") {\n            response.data = (await res.arrayBuffer());\n        }\n        else if (responseType === \"text\") {\n            await decodeText();\n        }\n        else if (responseType === \"webstream\") {\n            response.data = addAsyncIterator(res.body);\n        }\n        else {\n            /** axios defaults to JSON, and then text, we mimic the behaviour */\n            try {\n                let test = await res.clone().json();\n                if (typeof test !== \"object\") {\n                    await decodeText();\n                }\n                else {\n                    response.data = (await res.json());\n                }\n                test = null;\n            }\n            catch {\n                await decodeText();\n            }\n        }\n        return response;\n    }\n}\nexports[\"default\"] = Api;\n// | ReadableStream<Uint8Array>\nconst addAsyncIterator = (body) => {\n    const bodyWithIter = body;\n    if (typeof bodyWithIter[Symbol.asyncIterator] === \"undefined\") {\n        bodyWithIter[Symbol.asyncIterator] = webIiterator(body);\n    }\n    return bodyWithIter;\n};\nconst webIiterator = function (stream) {\n    return async function* iteratorGenerator() {\n        const reader = stream.getReader(); //lock\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    return;\n                yield value;\n            }\n        }\n        finally {\n            reader.releaseLock(); //unlock\n        }\n    };\n};\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2xpYi9hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG9DQUFvQztBQUNsRjtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELDJCQUEyQixxQkFBcUIsS0FBSyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUSxHQUFHLFNBQVM7QUFDbEU7QUFDQSxpQ0FBaUMsUUFBUSxHQUFHLFNBQVM7QUFDckQsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOENBQThDLFNBQVMsSUFBSSxXQUFXO0FBQ3RFO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FsaS9Eb3dubG9hZHMvcm91bGV0dGUgL25vZGVfbW9kdWxlcy9hcndlYXZlL25vZGUvbGliL2FwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEFwaSB7XG4gICAgTUVUSE9EX0dFVCA9IFwiR0VUXCI7XG4gICAgTUVUSE9EX1BPU1QgPSBcIlBPU1RcIjtcbiAgICBjb25maWc7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuYXBwbHlDb25maWcoY29uZmlnKTtcbiAgICB9XG4gICAgYXBwbHlDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gdGhpcy5tZXJnZURlZmF1bHRzKGNvbmZpZyk7XG4gICAgfVxuICAgIGdldENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnO1xuICAgIH1cbiAgICBtZXJnZURlZmF1bHRzKGNvbmZpZykge1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IGNvbmZpZy5wcm90b2NvbCB8fCBcImh0dHBcIjtcbiAgICAgICAgY29uc3QgcG9ydCA9IGNvbmZpZy5wb3J0IHx8IChwcm90b2NvbCA9PT0gXCJodHRwc1wiID8gNDQzIDogODApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9zdDogY29uZmlnLmhvc3QgfHwgXCIxMjcuMC4wLjFcIixcbiAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIHRpbWVvdXQ6IGNvbmZpZy50aW1lb3V0IHx8IDIwMDAwLFxuICAgICAgICAgICAgbG9nZ2luZzogY29uZmlnLmxvZ2dpbmcgfHwgZmFsc2UsXG4gICAgICAgICAgICBsb2dnZXI6IGNvbmZpZy5sb2dnZXIgfHwgY29uc29sZS5sb2csXG4gICAgICAgICAgICBuZXR3b3JrOiBjb25maWcubmV0d29yayxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KGVuZHBvaW50LCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdChlbmRwb2ludCwgeyAuLi5jb25maWcsIG1ldGhvZDogdGhpcy5NRVRIT0RfR0VUIH0pO1xuICAgIH1cbiAgICBhc3luYyBwb3N0KGVuZHBvaW50LCBib2R5LCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGNvbmZpZz8uaGVhZGVycyB8fCB7fSk7XG4gICAgICAgIGlmICghaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik/LmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKFwiYWNjZXB0XCIsIFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qXCIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXF1ZXN0KGVuZHBvaW50LCB7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBtZXRob2Q6IHRoaXMuTUVUSE9EX1BPU1QsXG4gICAgICAgICAgICBib2R5OiB0eXBlb2YgYm9keSAhPT0gXCJzdHJpbmdcIiA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogYm9keSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0KGVuZHBvaW50LCBpbml0KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0Py5oZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgY29uc3QgYmFzZVVSTCA9IGAke3RoaXMuY29uZmlnLnByb3RvY29sfTovLyR7dGhpcy5jb25maWcuaG9zdH06JHt0aGlzLmNvbmZpZy5wb3J0fWA7XG4gICAgICAgIC8qIHJlc3BvbnNlVHlwZSBpcyBwdXJlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggZXh0ZXJuYWwgYXBwcyAqL1xuICAgICAgICBjb25zdCByZXNwb25zZVR5cGUgPSBpbml0Py5yZXNwb25zZVR5cGU7XG4gICAgICAgIGRlbGV0ZSBpbml0Py5yZXNwb25zZVR5cGU7XG4gICAgICAgIGlmIChlbmRwb2ludC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgZW5kcG9pbnQgPSBlbmRwb2ludC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWcubmV0d29yaykge1xuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoXCJ4LW5ldHdvcmtcIiwgdGhpcy5jb25maWcubmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvZ2dlcihgUmVxdWVzdGluZzogJHtiYXNlVVJMfS8ke2VuZHBvaW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBmZXRjaChgJHtiYXNlVVJMfS8ke2VuZHBvaW50fWAsIHtcbiAgICAgICAgICAgIC4uLihpbml0IHx8IHt9KSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5jb25maWcubG9nZ2luZykge1xuICAgICAgICAgICAgdGhpcy5jb25maWcubG9nZ2VyKGBSZXNwb25zZTogICAke3Jlcy51cmx9IC0gJHtyZXMuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICBjb25zdCBjaGFyc2V0ID0gY29udGVudFR5cGU/Lm1hdGNoKC9jaGFyc2V0PShbXigpPD5ALDs6XFxcIi9bXFxdPy49XFxzXSopL2kpPy5bMV07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcmVzO1xuICAgICAgICBjb25zdCBkZWNvZGVUZXh0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYXJzZXQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5kYXRhID0gbmV3IFRleHREZWNvZGVyKGNoYXJzZXQpLmRlY29kZShhd2FpdCByZXMuYXJyYXlCdWZmZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSAoYXdhaXQgcmVzLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSA9IChhd2FpdCByZXMudGV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhID0gKGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICBhd2FpdCBkZWNvZGVUZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSBcIndlYnN0cmVhbVwiKSB7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhID0gYWRkQXN5bmNJdGVyYXRvcihyZXMuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiogYXhpb3MgZGVmYXVsdHMgdG8gSlNPTiwgYW5kIHRoZW4gdGV4dCwgd2UgbWltaWMgdGhlIGJlaGF2aW91ciAqL1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgdGVzdCA9IGF3YWl0IHJlcy5jbG9uZSgpLmpzb24oKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlc3QgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVjb2RlVGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YSA9IChhd2FpdCByZXMuanNvbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGVzdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGVjb2RlVGV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBcGk7XG4vLyB8IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG5jb25zdCBhZGRBc3luY0l0ZXJhdG9yID0gKGJvZHkpID0+IHtcbiAgICBjb25zdCBib2R5V2l0aEl0ZXIgPSBib2R5O1xuICAgIGlmICh0eXBlb2YgYm9keVdpdGhJdGVyW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBib2R5V2l0aEl0ZXJbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gd2ViSWl0ZXJhdG9yKGJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gYm9keVdpdGhJdGVyO1xufTtcbmNvbnN0IHdlYklpdGVyYXRvciA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24qIGl0ZXJhdG9yR2VuZXJhdG9yKCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7IC8vbG9ja1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTsgLy91bmxvY2tcbiAgICAgICAgfVxuICAgIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/lib/api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/lib/crypto/node-driver.js":
/*!*************************************************************!*\
  !*** ./node_modules/arweave/node/lib/crypto/node-driver.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst pem_1 = __webpack_require__(/*! ./pem */ \"(ssr)/./node_modules/arweave/node/lib/crypto/pem.js\");\nconst crypto = __importStar(__webpack_require__(/*! crypto */ \"crypto\"));\nclass NodeCryptoDriver {\n    keyLength = 4096;\n    publicExponent = 0x10001;\n    hashAlgorithm = \"sha256\";\n    encryptionAlgorithm = \"aes-256-cbc\";\n    generateJWK() {\n        if (typeof crypto.generateKeyPair != \"function\") {\n            throw new Error(\"Keypair generation not supported in this version of Node, only supported in versions 10+\");\n        }\n        return new Promise((resolve, reject) => {\n            crypto.generateKeyPair(\"rsa\", {\n                modulusLength: this.keyLength,\n                publicExponent: this.publicExponent,\n                privateKeyEncoding: {\n                    type: \"pkcs1\",\n                    format: \"pem\",\n                },\n                publicKeyEncoding: { type: \"pkcs1\", format: \"pem\" },\n            }, (err, publicKey, privateKey) => {\n                if (err) {\n                    reject(err);\n                }\n                resolve(this.pemToJWK(privateKey));\n            });\n        });\n    }\n    sign(jwk, data, { saltLength } = {}) {\n        return new Promise((resolve, reject) => {\n            resolve(crypto\n                .createSign(this.hashAlgorithm)\n                .update(data)\n                .sign({\n                key: this.jwkToPem(jwk),\n                padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n                saltLength,\n            }));\n        });\n    }\n    verify(publicModulus, data, signature) {\n        return new Promise((resolve, reject) => {\n            const publicJwk = {\n                kty: \"RSA\",\n                e: \"AQAB\",\n                n: publicModulus,\n            };\n            const pem = this.jwkToPem(publicJwk); //?\n            const keyObject = crypto.createPublicKey({\n                key: pem,\n                format: \"pem\",\n            });\n            const verify = crypto.createVerify(this.hashAlgorithm);\n            verify.update(data);\n            const verifyResult = verify.verify({\n                key: keyObject,\n                padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n            }, signature);\n            if (!verifyResult) {\n                const details = {\n                    asymmetricKeyType: keyObject.asymmetricKeyType,\n                    modulusLength: keyObject.asymmetricKeyDetails?.modulusLength,\n                };\n                console.warn(\"Transaction Verification Failed! \\n\" +\n                    `Details: ${JSON.stringify(details, null, 2)} \\n` +\n                    \"N.B. ArweaveJS is only guaranteed to verify txs created using ArweaveJS.\");\n            }\n            resolve(verifyResult);\n        });\n    }\n    hash(data, algorithm = \"SHA-256\") {\n        if (typeof data === \"string\") {\n            throw new TypeError(\"Data must be a Uint8Array\");\n        }\n        return new Promise((resolve, reject) => {\n            resolve(crypto\n                .createHash(this.parseHashAlgorithm(algorithm))\n                .update(data)\n                .digest());\n        });\n    }\n    /**\n     * If a key is passed as a buffer it *must* be exactly 32 bytes.\n     * If a key is passed as a string then any length may be used.\n     *\n     * @param {Buffer} data\n     * @param {(string | Buffer)} key\n     * @returns {Promise<Uint8Array>}\n     */\n    async encrypt(data, key, salt) {\n        // create a random string for deriving the key\n        // const salt = crypto.randomBytes(16);\n        // console.log(salt);\n        // As we're using CBC with a randomised IV per cypher we don't really need\n        // an additional random salt per passphrase.\n        const derivedKey = crypto.pbkdf2Sync(key, (salt = salt ? salt : \"salt\"), 100000, 32, this.hashAlgorithm);\n        const iv = crypto.randomBytes(16);\n        const cipher = crypto.createCipheriv(this.encryptionAlgorithm, derivedKey, iv);\n        const encrypted = Buffer.concat([iv, cipher.update(data), cipher.final()]);\n        return encrypted;\n    }\n    /**\n     * If a key is passed as a buffer it *must* be exactly 32 bytes.\n     * If a key is passed as a string then any length may be used.\n     *\n     * @param {Buffer} encrypted\n     * @param {(string | Buffer)} key\n     * @returns {Promise<Uint8Array>}\n     */\n    async decrypt(encrypted, key, salt) {\n        try {\n            // create a random string for deriving the key\n            // const salt = crypto.randomBytes(16).toString('hex');\n            // As we're using CBC with a randomised IV per cypher we don't really need\n            // an additional random salt per passphrase.\n            const derivedKey = crypto.pbkdf2Sync(key, (salt = salt ? salt : \"salt\"), 100000, 32, this.hashAlgorithm);\n            const iv = encrypted.slice(0, 16);\n            const data = encrypted.slice(16);\n            const decipher = crypto.createDecipheriv(this.encryptionAlgorithm, derivedKey, iv);\n            const decrypted = Buffer.concat([\n                decipher.update(data),\n                decipher.final(),\n            ]);\n            return decrypted;\n        }\n        catch (error) {\n            throw new Error(\"Failed to decrypt\");\n        }\n    }\n    jwkToPem(jwk) {\n        return (0, pem_1.jwkTopem)(jwk);\n    }\n    pemToJWK(pem) {\n        let jwk = (0, pem_1.pemTojwk)(pem);\n        return jwk;\n    }\n    parseHashAlgorithm(algorithm) {\n        switch (algorithm) {\n            case \"SHA-256\":\n                return \"sha256\";\n            case \"SHA-384\":\n                return \"sha384\";\n            default:\n                throw new Error(`Algorithm not supported: ${algorithm}`);\n        }\n    }\n}\nexports[\"default\"] = NodeCryptoDriver;\n//# sourceMappingURL=node-driver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2xpYi9jcnlwdG8vbm9kZS1kcml2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyxrRUFBTztBQUM3Qiw0QkFBNEIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixxQ0FBcUMsOEJBQThCO0FBQ25FLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxzQkFBc0IsYUFBYSxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLG1CQUFtQjtBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YWxpL0Rvd25sb2Fkcy9yb3VsZXR0ZSAvbm9kZV9tb2R1bGVzL2Fyd2VhdmUvbm9kZS9saWIvY3J5cHRvL25vZGUtZHJpdmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwZW1fMSA9IHJlcXVpcmUoXCIuL3BlbVwiKTtcbmNvbnN0IGNyeXB0byA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbmNsYXNzIE5vZGVDcnlwdG9Ecml2ZXIge1xuICAgIGtleUxlbmd0aCA9IDQwOTY7XG4gICAgcHVibGljRXhwb25lbnQgPSAweDEwMDAxO1xuICAgIGhhc2hBbGdvcml0aG0gPSBcInNoYTI1NlwiO1xuICAgIGVuY3J5cHRpb25BbGdvcml0aG0gPSBcImFlcy0yNTYtY2JjXCI7XG4gICAgZ2VuZXJhdGVKV0soKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3J5cHRvLmdlbmVyYXRlS2V5UGFpciAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleXBhaXIgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIGluIHRoaXMgdmVyc2lvbiBvZiBOb2RlLCBvbmx5IHN1cHBvcnRlZCBpbiB2ZXJzaW9ucyAxMCtcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNyeXB0by5nZW5lcmF0ZUtleVBhaXIoXCJyc2FcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IHRoaXMua2V5TGVuZ3RoLFxuICAgICAgICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiB0aGlzLnB1YmxpY0V4cG9uZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBrY3MxXCIsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogXCJwZW1cIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHB1YmxpY0tleUVuY29kaW5nOiB7IHR5cGU6IFwicGtjczFcIiwgZm9ybWF0OiBcInBlbVwiIH0sXG4gICAgICAgICAgICB9LCAoZXJyLCBwdWJsaWNLZXksIHByaXZhdGVLZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucGVtVG9KV0socHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduKGp3aywgZGF0YSwgeyBzYWx0TGVuZ3RoIH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShjcnlwdG9cbiAgICAgICAgICAgICAgICAuY3JlYXRlU2lnbih0aGlzLmhhc2hBbGdvcml0aG0pXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShkYXRhKVxuICAgICAgICAgICAgICAgIC5zaWduKHtcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuandrVG9QZW0oandrKSxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9QU1NfUEFERElORyxcbiAgICAgICAgICAgICAgICBzYWx0TGVuZ3RoLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmVyaWZ5KHB1YmxpY01vZHVsdXMsIGRhdGEsIHNpZ25hdHVyZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHVibGljSndrID0ge1xuICAgICAgICAgICAgICAgIGt0eTogXCJSU0FcIixcbiAgICAgICAgICAgICAgICBlOiBcIkFRQUJcIixcbiAgICAgICAgICAgICAgICBuOiBwdWJsaWNNb2R1bHVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBlbSA9IHRoaXMuandrVG9QZW0ocHVibGljSndrKTsgLy8/XG4gICAgICAgICAgICBjb25zdCBrZXlPYmplY3QgPSBjcnlwdG8uY3JlYXRlUHVibGljS2V5KHtcbiAgICAgICAgICAgICAgICBrZXk6IHBlbSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwicGVtXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHZlcmlmeSA9IGNyeXB0by5jcmVhdGVWZXJpZnkodGhpcy5oYXNoQWxnb3JpdGhtKTtcbiAgICAgICAgICAgIHZlcmlmeS51cGRhdGUoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCB2ZXJpZnlSZXN1bHQgPSB2ZXJpZnkudmVyaWZ5KHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleU9iamVjdCxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9QU1NfUEFERElORyxcbiAgICAgICAgICAgIH0sIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICBpZiAoIXZlcmlmeVJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW1tZXRyaWNLZXlUeXBlOiBrZXlPYmplY3QuYXN5bW1ldHJpY0tleVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IGtleU9iamVjdC5hc3ltbWV0cmljS2V5RGV0YWlscz8ubW9kdWx1c0xlbmd0aCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRyYW5zYWN0aW9uIFZlcmlmaWNhdGlvbiBGYWlsZWQhIFxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgYERldGFpbHM6ICR7SlNPTi5zdHJpbmdpZnkoZGV0YWlscywgbnVsbCwgMil9IFxcbmAgK1xuICAgICAgICAgICAgICAgICAgICBcIk4uQi4gQXJ3ZWF2ZUpTIGlzIG9ubHkgZ3VhcmFudGVlZCB0byB2ZXJpZnkgdHhzIGNyZWF0ZWQgdXNpbmcgQXJ3ZWF2ZUpTLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUodmVyaWZ5UmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhc2goZGF0YSwgYWxnb3JpdGhtID0gXCJTSEEtMjU2XCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGF0YSBtdXN0IGJlIGEgVWludDhBcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShjcnlwdG9cbiAgICAgICAgICAgICAgICAuY3JlYXRlSGFzaCh0aGlzLnBhcnNlSGFzaEFsZ29yaXRobShhbGdvcml0aG0pKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoZGF0YSlcbiAgICAgICAgICAgICAgICAuZGlnZXN0KCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYSBrZXkgaXMgcGFzc2VkIGFzIGEgYnVmZmVyIGl0ICptdXN0KiBiZSBleGFjdGx5IDMyIGJ5dGVzLlxuICAgICAqIElmIGEga2V5IGlzIHBhc3NlZCBhcyBhIHN0cmluZyB0aGVuIGFueSBsZW5ndGggbWF5IGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YVxuICAgICAqIEBwYXJhbSB7KHN0cmluZyB8IEJ1ZmZlcil9IGtleVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVpbnQ4QXJyYXk+fVxuICAgICAqL1xuICAgIGFzeW5jIGVuY3J5cHQoZGF0YSwga2V5LCBzYWx0KSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIHJhbmRvbSBzdHJpbmcgZm9yIGRlcml2aW5nIHRoZSBrZXlcbiAgICAgICAgLy8gY29uc3Qgc2FsdCA9IGNyeXB0by5yYW5kb21CeXRlcygxNik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHNhbHQpO1xuICAgICAgICAvLyBBcyB3ZSdyZSB1c2luZyBDQkMgd2l0aCBhIHJhbmRvbWlzZWQgSVYgcGVyIGN5cGhlciB3ZSBkb24ndCByZWFsbHkgbmVlZFxuICAgICAgICAvLyBhbiBhZGRpdGlvbmFsIHJhbmRvbSBzYWx0IHBlciBwYXNzcGhyYXNlLlxuICAgICAgICBjb25zdCBkZXJpdmVkS2V5ID0gY3J5cHRvLnBia2RmMlN5bmMoa2V5LCAoc2FsdCA9IHNhbHQgPyBzYWx0IDogXCJzYWx0XCIpLCAxMDAwMDAsIDMyLCB0aGlzLmhhc2hBbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBpdiA9IGNyeXB0by5yYW5kb21CeXRlcygxNik7XG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdih0aGlzLmVuY3J5cHRpb25BbGdvcml0aG0sIGRlcml2ZWRLZXksIGl2KTtcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkID0gQnVmZmVyLmNvbmNhdChbaXYsIGNpcGhlci51cGRhdGUoZGF0YSksIGNpcGhlci5maW5hbCgpXSk7XG4gICAgICAgIHJldHVybiBlbmNyeXB0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGEga2V5IGlzIHBhc3NlZCBhcyBhIGJ1ZmZlciBpdCAqbXVzdCogYmUgZXhhY3RseSAzMiBieXRlcy5cbiAgICAgKiBJZiBhIGtleSBpcyBwYXNzZWQgYXMgYSBzdHJpbmcgdGhlbiBhbnkgbGVuZ3RoIG1heSBiZSB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGVuY3J5cHRlZFxuICAgICAqIEBwYXJhbSB7KHN0cmluZyB8IEJ1ZmZlcil9IGtleVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFVpbnQ4QXJyYXk+fVxuICAgICAqL1xuICAgIGFzeW5jIGRlY3J5cHQoZW5jcnlwdGVkLCBrZXksIHNhbHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHJhbmRvbSBzdHJpbmcgZm9yIGRlcml2aW5nIHRoZSBrZXlcbiAgICAgICAgICAgIC8vIGNvbnN0IHNhbHQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgIC8vIEFzIHdlJ3JlIHVzaW5nIENCQyB3aXRoIGEgcmFuZG9taXNlZCBJViBwZXIgY3lwaGVyIHdlIGRvbid0IHJlYWxseSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhZGRpdGlvbmFsIHJhbmRvbSBzYWx0IHBlciBwYXNzcGhyYXNlLlxuICAgICAgICAgICAgY29uc3QgZGVyaXZlZEtleSA9IGNyeXB0by5wYmtkZjJTeW5jKGtleSwgKHNhbHQgPSBzYWx0ID8gc2FsdCA6IFwic2FsdFwiKSwgMTAwMDAwLCAzMiwgdGhpcy5oYXNoQWxnb3JpdGhtKTtcbiAgICAgICAgICAgIGNvbnN0IGl2ID0gZW5jcnlwdGVkLnNsaWNlKDAsIDE2KTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlbmNyeXB0ZWQuc2xpY2UoMTYpO1xuICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdih0aGlzLmVuY3J5cHRpb25BbGdvcml0aG0sIGRlcml2ZWRLZXksIGl2KTtcbiAgICAgICAgICAgIGNvbnN0IGRlY3J5cHRlZCA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgICAgIGRlY2lwaGVyLnVwZGF0ZShkYXRhKSxcbiAgICAgICAgICAgICAgICBkZWNpcGhlci5maW5hbCgpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gZGVjcnlwdGVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgandrVG9QZW0oandrKSB7XG4gICAgICAgIHJldHVybiAoMCwgcGVtXzEuandrVG9wZW0pKGp3ayk7XG4gICAgfVxuICAgIHBlbVRvSldLKHBlbSkge1xuICAgICAgICBsZXQgandrID0gKDAsIHBlbV8xLnBlbVRvandrKShwZW0pO1xuICAgICAgICByZXR1cm4gandrO1xuICAgIH1cbiAgICBwYXJzZUhhc2hBbGdvcml0aG0oYWxnb3JpdGhtKSB7XG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICBjYXNlIFwiU0hBLTI1NlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTI1NlwiO1xuICAgICAgICAgICAgY2FzZSBcIlNIQS0zODRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGEzODRcIjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbGdvcml0aG0gbm90IHN1cHBvcnRlZDogJHthbGdvcml0aG19YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBOb2RlQ3J5cHRvRHJpdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS1kcml2ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/lib/crypto/node-driver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/lib/crypto/pem.js":
/*!*****************************************************!*\
  !*** ./node_modules/arweave/node/lib/crypto/pem.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pemTojwk = pemTojwk;\nexports.jwkTopem = jwkTopem;\n// @ts-ignore\nconst asn = __importStar(__webpack_require__(/*! asn1.js */ \"(ssr)/./node_modules/asn1.js/lib/asn1.js\"));\nfunction urlize(base64) {\n    return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\nfunction hex2b64url(str) {\n    return urlize(Buffer.from(str, \"hex\").toString(\"base64\"));\n}\nvar RSAPublicKey = asn.define(\"RSAPublicKey\", function () {\n    this.seq().obj(this.key(\"n\").int(), this.key(\"e\").int());\n});\nvar AlgorithmIdentifier = asn.define(\"AlgorithmIdentifier\", function () {\n    this.seq().obj(this.key(\"algorithm\").objid(), this.key(\"parameters\").optional().any());\n});\nvar PublicKeyInfo = asn.define(\"PublicKeyInfo\", function () {\n    this.seq().obj(this.key(\"algorithm\").use(AlgorithmIdentifier), this.key(\"publicKey\").bitstr());\n});\nvar Version = asn.define(\"Version\", function () {\n    this.int({\n        0: \"two-prime\",\n        1: \"multi\",\n    });\n});\nvar OtherPrimeInfos = asn.define(\"OtherPrimeInfos\", function () {\n    this.seq().obj(this.key(\"ri\").int(), this.key(\"di\").int(), this.key(\"ti\").int());\n});\nvar RSAPrivateKey = asn.define(\"RSAPrivateKey\", function () {\n    this.seq().obj(this.key(\"version\").use(Version), this.key(\"n\").int(), this.key(\"e\").int(), this.key(\"d\").int(), this.key(\"p\").int(), this.key(\"q\").int(), this.key(\"dp\").int(), this.key(\"dq\").int(), this.key(\"qi\").int(), this.key(\"other\").optional().use(OtherPrimeInfos));\n});\nvar PrivateKeyInfo = asn.define(\"PrivateKeyInfo\", function () {\n    this.seq().obj(this.key(\"version\").use(Version), this.key(\"algorithm\").use(AlgorithmIdentifier), this.key(\"privateKey\").bitstr());\n});\nconst RSA_OID = \"1.2.840.113549.1.1.1\";\nfunction addExtras(obj, extras) {\n    extras = extras || {};\n    Object.keys(extras).forEach(function (key) {\n        obj[key] = extras[key];\n    });\n    return obj;\n}\nfunction pad(hex) {\n    return hex.length % 2 === 1 ? \"0\" + hex : hex;\n}\nfunction decodeRsaPublic(buffer, extras) {\n    var key = RSAPublicKey.decode(buffer, \"der\");\n    var e = pad(key.e.toString(16));\n    var jwk = {\n        kty: \"RSA\",\n        n: bn2base64url(key.n),\n        e: hex2b64url(e),\n    };\n    return addExtras(jwk, extras);\n}\nfunction decodeRsaPrivate(buffer, extras) {\n    var key = RSAPrivateKey.decode(buffer, \"der\");\n    var e = pad(key.e.toString(16));\n    var jwk = {\n        kty: \"RSA\",\n        n: bn2base64url(key.n),\n        e: hex2b64url(e),\n        d: bn2base64url(key.d),\n        p: bn2base64url(key.p),\n        q: bn2base64url(key.q),\n        dp: bn2base64url(key.dp),\n        dq: bn2base64url(key.dq),\n        qi: bn2base64url(key.qi),\n    };\n    return addExtras(jwk, extras);\n}\nfunction decodePublic(buffer, extras) {\n    var info = PublicKeyInfo.decode(buffer, \"der\");\n    return decodeRsaPublic(info.publicKey.data, extras);\n}\nfunction decodePrivate(buffer, extras) {\n    var info = PrivateKeyInfo.decode(buffer, \"der\");\n    return decodeRsaPrivate(info.privateKey.data, extras);\n}\nfunction getDecoder(header) {\n    var match = /^-----BEGIN (RSA )?(PUBLIC|PRIVATE) KEY-----$/.exec(header);\n    if (!match) {\n        return null;\n    }\n    var isRSA = !!match[1];\n    var isPrivate = match[2] === \"PRIVATE\";\n    if (isPrivate) {\n        return isRSA ? decodeRsaPrivate : decodePrivate;\n    }\n    else {\n        return isRSA ? decodeRsaPublic : decodePublic;\n    }\n}\nfunction parse(jwk) {\n    return {\n        n: string2bn(jwk.n),\n        e: string2bn(jwk.e),\n        d: jwk.d && string2bn(jwk.d),\n        p: jwk.p && string2bn(jwk.p),\n        q: jwk.q && string2bn(jwk.q),\n        dp: jwk.dp && string2bn(jwk.dp),\n        dq: jwk.dq && string2bn(jwk.dq),\n        qi: jwk.qi && string2bn(jwk.qi),\n    };\n}\nfunction bn2base64url(bn) {\n    return hex2b64url(pad(bn.toString(16)));\n}\nfunction base64url2bn(str) {\n    return new asn.bignum(Buffer.from(str, \"base64\"));\n}\nfunction string2bn(str) {\n    if (/^[0-9]+$/.test(str)) {\n        return new asn.bignum(str, 10);\n    }\n    return base64url2bn(str);\n}\nfunction pemTojwk(pem, extras) {\n    var text = pem.toString().split(/(\\r\\n|\\r|\\n)+/g);\n    text = text.filter(function (line) {\n        return line.trim().length !== 0;\n    });\n    var decoder = getDecoder(text[0]);\n    text = text.slice(1, -1).join(\"\");\n    return decoder(Buffer.from(text.replace(/[^\\w\\d\\+\\/=]+/g, \"\"), \"base64\"), extras);\n}\nfunction jwkTopem(json) {\n    var jwk = parse(json);\n    var isPrivate = !!jwk.d;\n    var t = isPrivate ? \"PRIVATE\" : \"PUBLIC\";\n    var header = \"-----BEGIN RSA \" + t + \" KEY-----\\n\";\n    var footer = \"\\n-----END RSA \" + t + \" KEY-----\\n\";\n    var data = Buffer.alloc(0);\n    if (isPrivate) {\n        jwk.version = \"two-prime\";\n        data = RSAPrivateKey.encode(jwk, \"der\");\n    }\n    else {\n        data = RSAPublicKey.encode(jwk, \"der\");\n    }\n    var body = data\n        .toString(\"base64\")\n        .match(/.{1,64}/g)\n        .join(\"\\n\");\n    return header + body + footer;\n}\n//# sourceMappingURL=pem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2xpYi9jcnlwdG8vcGVtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMseURBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbGkvRG93bmxvYWRzL3JvdWxldHRlIC9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2xpYi9jcnlwdG8vcGVtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBlbVRvandrID0gcGVtVG9qd2s7XG5leHBvcnRzLmp3a1RvcGVtID0gandrVG9wZW07XG4vLyBAdHMtaWdub3JlXG5jb25zdCBhc24gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImFzbjEuanNcIikpO1xuZnVuY3Rpb24gdXJsaXplKGJhc2U2NCkge1xuICAgIHJldHVybiBiYXNlNjQucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLz0vZywgXCJcIik7XG59XG5mdW5jdGlvbiBoZXgyYjY0dXJsKHN0cikge1xuICAgIHJldHVybiB1cmxpemUoQnVmZmVyLmZyb20oc3RyLCBcImhleFwiKS50b1N0cmluZyhcImJhc2U2NFwiKSk7XG59XG52YXIgUlNBUHVibGljS2V5ID0gYXNuLmRlZmluZShcIlJTQVB1YmxpY0tleVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXEoKS5vYmoodGhpcy5rZXkoXCJuXCIpLmludCgpLCB0aGlzLmtleShcImVcIikuaW50KCkpO1xufSk7XG52YXIgQWxnb3JpdGhtSWRlbnRpZmllciA9IGFzbi5kZWZpbmUoXCJBbGdvcml0aG1JZGVudGlmaWVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNlcSgpLm9iaih0aGlzLmtleShcImFsZ29yaXRobVwiKS5vYmppZCgpLCB0aGlzLmtleShcInBhcmFtZXRlcnNcIikub3B0aW9uYWwoKS5hbnkoKSk7XG59KTtcbnZhciBQdWJsaWNLZXlJbmZvID0gYXNuLmRlZmluZShcIlB1YmxpY0tleUluZm9cIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VxKCkub2JqKHRoaXMua2V5KFwiYWxnb3JpdGhtXCIpLnVzZShBbGdvcml0aG1JZGVudGlmaWVyKSwgdGhpcy5rZXkoXCJwdWJsaWNLZXlcIikuYml0c3RyKCkpO1xufSk7XG52YXIgVmVyc2lvbiA9IGFzbi5kZWZpbmUoXCJWZXJzaW9uXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmludCh7XG4gICAgICAgIDA6IFwidHdvLXByaW1lXCIsXG4gICAgICAgIDE6IFwibXVsdGlcIixcbiAgICB9KTtcbn0pO1xudmFyIE90aGVyUHJpbWVJbmZvcyA9IGFzbi5kZWZpbmUoXCJPdGhlclByaW1lSW5mb3NcIiwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VxKCkub2JqKHRoaXMua2V5KFwicmlcIikuaW50KCksIHRoaXMua2V5KFwiZGlcIikuaW50KCksIHRoaXMua2V5KFwidGlcIikuaW50KCkpO1xufSk7XG52YXIgUlNBUHJpdmF0ZUtleSA9IGFzbi5kZWZpbmUoXCJSU0FQcml2YXRlS2V5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNlcSgpLm9iaih0aGlzLmtleShcInZlcnNpb25cIikudXNlKFZlcnNpb24pLCB0aGlzLmtleShcIm5cIikuaW50KCksIHRoaXMua2V5KFwiZVwiKS5pbnQoKSwgdGhpcy5rZXkoXCJkXCIpLmludCgpLCB0aGlzLmtleShcInBcIikuaW50KCksIHRoaXMua2V5KFwicVwiKS5pbnQoKSwgdGhpcy5rZXkoXCJkcFwiKS5pbnQoKSwgdGhpcy5rZXkoXCJkcVwiKS5pbnQoKSwgdGhpcy5rZXkoXCJxaVwiKS5pbnQoKSwgdGhpcy5rZXkoXCJvdGhlclwiKS5vcHRpb25hbCgpLnVzZShPdGhlclByaW1lSW5mb3MpKTtcbn0pO1xudmFyIFByaXZhdGVLZXlJbmZvID0gYXNuLmRlZmluZShcIlByaXZhdGVLZXlJbmZvXCIsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNlcSgpLm9iaih0aGlzLmtleShcInZlcnNpb25cIikudXNlKFZlcnNpb24pLCB0aGlzLmtleShcImFsZ29yaXRobVwiKS51c2UoQWxnb3JpdGhtSWRlbnRpZmllciksIHRoaXMua2V5KFwicHJpdmF0ZUtleVwiKS5iaXRzdHIoKSk7XG59KTtcbmNvbnN0IFJTQV9PSUQgPSBcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCI7XG5mdW5jdGlvbiBhZGRFeHRyYXMob2JqLCBleHRyYXMpIHtcbiAgICBleHRyYXMgPSBleHRyYXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZXh0cmFzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBleHRyYXNba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gcGFkKGhleCkge1xuICAgIHJldHVybiBoZXgubGVuZ3RoICUgMiA9PT0gMSA/IFwiMFwiICsgaGV4IDogaGV4O1xufVxuZnVuY3Rpb24gZGVjb2RlUnNhUHVibGljKGJ1ZmZlciwgZXh0cmFzKSB7XG4gICAgdmFyIGtleSA9IFJTQVB1YmxpY0tleS5kZWNvZGUoYnVmZmVyLCBcImRlclwiKTtcbiAgICB2YXIgZSA9IHBhZChrZXkuZS50b1N0cmluZygxNikpO1xuICAgIHZhciBqd2sgPSB7XG4gICAgICAgIGt0eTogXCJSU0FcIixcbiAgICAgICAgbjogYm4yYmFzZTY0dXJsKGtleS5uKSxcbiAgICAgICAgZTogaGV4MmI2NHVybChlKSxcbiAgICB9O1xuICAgIHJldHVybiBhZGRFeHRyYXMoandrLCBleHRyYXMpO1xufVxuZnVuY3Rpb24gZGVjb2RlUnNhUHJpdmF0ZShidWZmZXIsIGV4dHJhcykge1xuICAgIHZhciBrZXkgPSBSU0FQcml2YXRlS2V5LmRlY29kZShidWZmZXIsIFwiZGVyXCIpO1xuICAgIHZhciBlID0gcGFkKGtleS5lLnRvU3RyaW5nKDE2KSk7XG4gICAgdmFyIGp3ayA9IHtcbiAgICAgICAga3R5OiBcIlJTQVwiLFxuICAgICAgICBuOiBibjJiYXNlNjR1cmwoa2V5Lm4pLFxuICAgICAgICBlOiBoZXgyYjY0dXJsKGUpLFxuICAgICAgICBkOiBibjJiYXNlNjR1cmwoa2V5LmQpLFxuICAgICAgICBwOiBibjJiYXNlNjR1cmwoa2V5LnApLFxuICAgICAgICBxOiBibjJiYXNlNjR1cmwoa2V5LnEpLFxuICAgICAgICBkcDogYm4yYmFzZTY0dXJsKGtleS5kcCksXG4gICAgICAgIGRxOiBibjJiYXNlNjR1cmwoa2V5LmRxKSxcbiAgICAgICAgcWk6IGJuMmJhc2U2NHVybChrZXkucWkpLFxuICAgIH07XG4gICAgcmV0dXJuIGFkZEV4dHJhcyhqd2ssIGV4dHJhcyk7XG59XG5mdW5jdGlvbiBkZWNvZGVQdWJsaWMoYnVmZmVyLCBleHRyYXMpIHtcbiAgICB2YXIgaW5mbyA9IFB1YmxpY0tleUluZm8uZGVjb2RlKGJ1ZmZlciwgXCJkZXJcIik7XG4gICAgcmV0dXJuIGRlY29kZVJzYVB1YmxpYyhpbmZvLnB1YmxpY0tleS5kYXRhLCBleHRyYXMpO1xufVxuZnVuY3Rpb24gZGVjb2RlUHJpdmF0ZShidWZmZXIsIGV4dHJhcykge1xuICAgIHZhciBpbmZvID0gUHJpdmF0ZUtleUluZm8uZGVjb2RlKGJ1ZmZlciwgXCJkZXJcIik7XG4gICAgcmV0dXJuIGRlY29kZVJzYVByaXZhdGUoaW5mby5wcml2YXRlS2V5LmRhdGEsIGV4dHJhcyk7XG59XG5mdW5jdGlvbiBnZXREZWNvZGVyKGhlYWRlcikge1xuICAgIHZhciBtYXRjaCA9IC9eLS0tLS1CRUdJTiAoUlNBICk/KFBVQkxJQ3xQUklWQVRFKSBLRVktLS0tLSQvLmV4ZWMoaGVhZGVyKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgaXNSU0EgPSAhIW1hdGNoWzFdO1xuICAgIHZhciBpc1ByaXZhdGUgPSBtYXRjaFsyXSA9PT0gXCJQUklWQVRFXCI7XG4gICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICByZXR1cm4gaXNSU0EgPyBkZWNvZGVSc2FQcml2YXRlIDogZGVjb2RlUHJpdmF0ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpc1JTQSA/IGRlY29kZVJzYVB1YmxpYyA6IGRlY29kZVB1YmxpYztcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZShqd2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuOiBzdHJpbmcyYm4oandrLm4pLFxuICAgICAgICBlOiBzdHJpbmcyYm4oandrLmUpLFxuICAgICAgICBkOiBqd2suZCAmJiBzdHJpbmcyYm4oandrLmQpLFxuICAgICAgICBwOiBqd2sucCAmJiBzdHJpbmcyYm4oandrLnApLFxuICAgICAgICBxOiBqd2sucSAmJiBzdHJpbmcyYm4oandrLnEpLFxuICAgICAgICBkcDogandrLmRwICYmIHN0cmluZzJibihqd2suZHApLFxuICAgICAgICBkcTogandrLmRxICYmIHN0cmluZzJibihqd2suZHEpLFxuICAgICAgICBxaTogandrLnFpICYmIHN0cmluZzJibihqd2sucWkpLFxuICAgIH07XG59XG5mdW5jdGlvbiBibjJiYXNlNjR1cmwoYm4pIHtcbiAgICByZXR1cm4gaGV4MmI2NHVybChwYWQoYm4udG9TdHJpbmcoMTYpKSk7XG59XG5mdW5jdGlvbiBiYXNlNjR1cmwyYm4oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBhc24uYmlnbnVtKEJ1ZmZlci5mcm9tKHN0ciwgXCJiYXNlNjRcIikpO1xufVxuZnVuY3Rpb24gc3RyaW5nMmJuKHN0cikge1xuICAgIGlmICgvXlswLTldKyQvLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gbmV3IGFzbi5iaWdudW0oc3RyLCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjR1cmwyYm4oc3RyKTtcbn1cbmZ1bmN0aW9uIHBlbVRvandrKHBlbSwgZXh0cmFzKSB7XG4gICAgdmFyIHRleHQgPSBwZW0udG9TdHJpbmcoKS5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKSsvZyk7XG4gICAgdGV4dCA9IHRleHQuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiBsaW5lLnRyaW0oKS5sZW5ndGggIT09IDA7XG4gICAgfSk7XG4gICAgdmFyIGRlY29kZXIgPSBnZXREZWNvZGVyKHRleHRbMF0pO1xuICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEsIC0xKS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBkZWNvZGVyKEJ1ZmZlci5mcm9tKHRleHQucmVwbGFjZSgvW15cXHdcXGRcXCtcXC89XSsvZywgXCJcIiksIFwiYmFzZTY0XCIpLCBleHRyYXMpO1xufVxuZnVuY3Rpb24gandrVG9wZW0oanNvbikge1xuICAgIHZhciBqd2sgPSBwYXJzZShqc29uKTtcbiAgICB2YXIgaXNQcml2YXRlID0gISFqd2suZDtcbiAgICB2YXIgdCA9IGlzUHJpdmF0ZSA/IFwiUFJJVkFURVwiIDogXCJQVUJMSUNcIjtcbiAgICB2YXIgaGVhZGVyID0gXCItLS0tLUJFR0lOIFJTQSBcIiArIHQgKyBcIiBLRVktLS0tLVxcblwiO1xuICAgIHZhciBmb290ZXIgPSBcIlxcbi0tLS0tRU5EIFJTQSBcIiArIHQgKyBcIiBLRVktLS0tLVxcblwiO1xuICAgIHZhciBkYXRhID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgandrLnZlcnNpb24gPSBcInR3by1wcmltZVwiO1xuICAgICAgICBkYXRhID0gUlNBUHJpdmF0ZUtleS5lbmNvZGUoandrLCBcImRlclwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGEgPSBSU0FQdWJsaWNLZXkuZW5jb2RlKGp3aywgXCJkZXJcIik7XG4gICAgfVxuICAgIHZhciBib2R5ID0gZGF0YVxuICAgICAgICAudG9TdHJpbmcoXCJiYXNlNjRcIilcbiAgICAgICAgLm1hdGNoKC8uezEsNjR9L2cpXG4gICAgICAgIC5qb2luKFwiXFxuXCIpO1xuICAgIHJldHVybiBoZWFkZXIgKyBib2R5ICsgZm9vdGVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/lib/crypto/pem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/lib/deepHash.js":
/*!***************************************************!*\
  !*** ./node_modules/arweave/node/lib/deepHash.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = deepHash;\nconst common_1 = __importDefault(__webpack_require__(/*! ../common */ \"(ssr)/./node_modules/arweave/node/common.js\"));\nasync function deepHash(data) {\n    if (Array.isArray(data)) {\n        const tag = common_1.default.utils.concatBuffers([\n            common_1.default.utils.stringToBuffer(\"list\"),\n            common_1.default.utils.stringToBuffer(data.length.toString()),\n        ]);\n        return await deepHashChunks(data, await common_1.default.crypto.hash(tag, \"SHA-384\"));\n    }\n    const tag = common_1.default.utils.concatBuffers([\n        common_1.default.utils.stringToBuffer(\"blob\"),\n        common_1.default.utils.stringToBuffer(data.byteLength.toString()),\n    ]);\n    const taggedHash = common_1.default.utils.concatBuffers([\n        await common_1.default.crypto.hash(tag, \"SHA-384\"),\n        await common_1.default.crypto.hash(data, \"SHA-384\"),\n    ]);\n    return await common_1.default.crypto.hash(taggedHash, \"SHA-384\");\n}\nasync function deepHashChunks(chunks, acc) {\n    if (chunks.length < 1) {\n        return acc;\n    }\n    const hashPair = common_1.default.utils.concatBuffers([\n        acc,\n        await deepHash(chunks[0]),\n    ]);\n    const newAcc = await common_1.default.crypto.hash(hashPair, \"SHA-384\");\n    return await deepHashChunks(chunks.slice(1), newAcc);\n}\n//# sourceMappingURL=deepHash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2xpYi9kZWVwSGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFlO0FBQ2YsaUNBQWlDLG1CQUFPLENBQUMsOERBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FsaS9Eb3dubG9hZHMvcm91bGV0dGUgL25vZGVfbW9kdWxlcy9hcndlYXZlL25vZGUvbGliL2RlZXBIYXNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVlcEhhc2g7XG5jb25zdCBjb21tb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vY29tbW9uXCIpKTtcbmFzeW5jIGZ1bmN0aW9uIGRlZXBIYXNoKGRhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBjb25zdCB0YWcgPSBjb21tb25fMS5kZWZhdWx0LnV0aWxzLmNvbmNhdEJ1ZmZlcnMoW1xuICAgICAgICAgICAgY29tbW9uXzEuZGVmYXVsdC51dGlscy5zdHJpbmdUb0J1ZmZlcihcImxpc3RcIiksXG4gICAgICAgICAgICBjb21tb25fMS5kZWZhdWx0LnV0aWxzLnN0cmluZ1RvQnVmZmVyKGRhdGEubGVuZ3RoLnRvU3RyaW5nKCkpLFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRlZXBIYXNoQ2h1bmtzKGRhdGEsIGF3YWl0IGNvbW1vbl8xLmRlZmF1bHQuY3J5cHRvLmhhc2godGFnLCBcIlNIQS0zODRcIikpO1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBjb21tb25fMS5kZWZhdWx0LnV0aWxzLmNvbmNhdEJ1ZmZlcnMoW1xuICAgICAgICBjb21tb25fMS5kZWZhdWx0LnV0aWxzLnN0cmluZ1RvQnVmZmVyKFwiYmxvYlwiKSxcbiAgICAgICAgY29tbW9uXzEuZGVmYXVsdC51dGlscy5zdHJpbmdUb0J1ZmZlcihkYXRhLmJ5dGVMZW5ndGgudG9TdHJpbmcoKSksXG4gICAgXSk7XG4gICAgY29uc3QgdGFnZ2VkSGFzaCA9IGNvbW1vbl8xLmRlZmF1bHQudXRpbHMuY29uY2F0QnVmZmVycyhbXG4gICAgICAgIGF3YWl0IGNvbW1vbl8xLmRlZmF1bHQuY3J5cHRvLmhhc2godGFnLCBcIlNIQS0zODRcIiksXG4gICAgICAgIGF3YWl0IGNvbW1vbl8xLmRlZmF1bHQuY3J5cHRvLmhhc2goZGF0YSwgXCJTSEEtMzg0XCIpLFxuICAgIF0pO1xuICAgIHJldHVybiBhd2FpdCBjb21tb25fMS5kZWZhdWx0LmNyeXB0by5oYXNoKHRhZ2dlZEhhc2gsIFwiU0hBLTM4NFwiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlZXBIYXNoQ2h1bmtzKGNodW5rcywgYWNjKSB7XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hQYWlyID0gY29tbW9uXzEuZGVmYXVsdC51dGlscy5jb25jYXRCdWZmZXJzKFtcbiAgICAgICAgYWNjLFxuICAgICAgICBhd2FpdCBkZWVwSGFzaChjaHVua3NbMF0pLFxuICAgIF0pO1xuICAgIGNvbnN0IG5ld0FjYyA9IGF3YWl0IGNvbW1vbl8xLmRlZmF1bHQuY3J5cHRvLmhhc2goaGFzaFBhaXIsIFwiU0hBLTM4NFwiKTtcbiAgICByZXR1cm4gYXdhaXQgZGVlcEhhc2hDaHVua3MoY2h1bmtzLnNsaWNlKDEpLCBuZXdBY2MpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVlcEhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/lib/deepHash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/lib/error.js":
/*!************************************************!*\
  !*** ./node_modules/arweave/node/lib/error.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getError = getError;\nclass ArweaveError extends Error {\n    type;\n    response;\n    constructor(type, optional = {}) {\n        if (optional.message) {\n            super(optional.message);\n        }\n        else {\n            super();\n        }\n        this.type = type;\n        this.response = optional.response;\n    }\n    getType() {\n        return this.type;\n    }\n}\nexports[\"default\"] = ArweaveError;\n// Safely get error string\n// from a response, falling back to\n// resp.data, statusText or 'unknown'.\n// Note: a wrongly set content-type can\n// cause what is a json response to be interepted\n// as a string or Buffer, so we handle that too.\nfunction getError(resp) {\n    let data = resp.data;\n    if (typeof resp.data === \"string\") {\n        try {\n            data = JSON.parse(resp.data);\n        }\n        catch (e) { }\n    }\n    if (resp.data instanceof ArrayBuffer || resp.data instanceof Uint8Array) {\n        try {\n            data = JSON.parse(data.toString());\n        }\n        catch (e) { }\n    }\n    return data ? data.error || data : resp.statusText || \"unknown\";\n}\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2xpYi9lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FsaS9Eb3dubG9hZHMvcm91bGV0dGUgL25vZGVfbW9kdWxlcy9hcndlYXZlL25vZGUvbGliL2Vycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFcnJvciA9IGdldEVycm9yO1xuY2xhc3MgQXJ3ZWF2ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIHR5cGU7XG4gICAgcmVzcG9uc2U7XG4gICAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9uYWwgPSB7fSkge1xuICAgICAgICBpZiAob3B0aW9uYWwubWVzc2FnZSkge1xuICAgICAgICAgICAgc3VwZXIob3B0aW9uYWwubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSBvcHRpb25hbC5yZXNwb25zZTtcbiAgICB9XG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBcndlYXZlRXJyb3I7XG4vLyBTYWZlbHkgZ2V0IGVycm9yIHN0cmluZ1xuLy8gZnJvbSBhIHJlc3BvbnNlLCBmYWxsaW5nIGJhY2sgdG9cbi8vIHJlc3AuZGF0YSwgc3RhdHVzVGV4dCBvciAndW5rbm93bicuXG4vLyBOb3RlOiBhIHdyb25nbHkgc2V0IGNvbnRlbnQtdHlwZSBjYW5cbi8vIGNhdXNlIHdoYXQgaXMgYSBqc29uIHJlc3BvbnNlIHRvIGJlIGludGVyZXB0ZWRcbi8vIGFzIGEgc3RyaW5nIG9yIEJ1ZmZlciwgc28gd2UgaGFuZGxlIHRoYXQgdG9vLlxuZnVuY3Rpb24gZ2V0RXJyb3IocmVzcCkge1xuICAgIGxldCBkYXRhID0gcmVzcC5kYXRhO1xuICAgIGlmICh0eXBlb2YgcmVzcC5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShyZXNwLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgaWYgKHJlc3AuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IHJlc3AuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YSA/IGRhdGEuZXJyb3IgfHwgZGF0YSA6IHJlc3Auc3RhdHVzVGV4dCB8fCBcInVua25vd25cIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/lib/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/lib/merkle.js":
/*!*************************************************!*\
  !*** ./node_modules/arweave/node/lib/merkle.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.arrayCompare = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;\nexports.chunkData = chunkData;\nexports.generateLeaves = generateLeaves;\nexports.computeRootHash = computeRootHash;\nexports.generateTree = generateTree;\nexports.generateTransactionChunks = generateTransactionChunks;\nexports.buildLayers = buildLayers;\nexports.generateProofs = generateProofs;\nexports.arrayFlatten = arrayFlatten;\nexports.intToBuffer = intToBuffer;\nexports.bufferToInt = bufferToInt;\nexports.validatePath = validatePath;\nexports.debug = debug;\n/**\n * @see {@link https://github.com/ArweaveTeam/arweave/blob/fbc381e0e36efffa45d13f2faa6199d3766edaa2/apps/arweave/src/ar_merkle.erl}\n */\nconst common_1 = __importDefault(__webpack_require__(/*! ../common */ \"(ssr)/./node_modules/arweave/node/common.js\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/arweave/node/lib/utils.js\");\nexports.MAX_CHUNK_SIZE = 256 * 1024;\nexports.MIN_CHUNK_SIZE = 32 * 1024;\nconst NOTE_SIZE = 32;\nconst HASH_SIZE = 32;\n/**\n * Takes the input data and chunks it into (mostly) equal sized chunks.\n * The last chunk will be a bit smaller as it contains the remainder\n * from the chunking process.\n */\nasync function chunkData(data) {\n    let chunks = [];\n    let rest = data;\n    let cursor = 0;\n    while (rest.byteLength >= exports.MAX_CHUNK_SIZE) {\n        let chunkSize = exports.MAX_CHUNK_SIZE;\n        // If the total bytes left will produce a chunk < MIN_CHUNK_SIZE,\n        // then adjust the amount we put in this 2nd last chunk.\n        let nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;\n        if (nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE) {\n            chunkSize = Math.ceil(rest.byteLength / 2);\n            // console.log(`Last chunk will be: ${nextChunkSize} which is below ${MIN_CHUNK_SIZE}, adjusting current to ${chunkSize} with ${rest.byteLength} left.`)\n        }\n        const chunk = rest.slice(0, chunkSize);\n        const dataHash = await common_1.default.crypto.hash(chunk);\n        cursor += chunk.byteLength;\n        chunks.push({\n            dataHash,\n            minByteRange: cursor - chunk.byteLength,\n            maxByteRange: cursor,\n        });\n        rest = rest.slice(chunkSize);\n    }\n    chunks.push({\n        dataHash: await common_1.default.crypto.hash(rest),\n        minByteRange: cursor,\n        maxByteRange: cursor + rest.byteLength,\n    });\n    return chunks;\n}\nasync function generateLeaves(chunks) {\n    return Promise.all(chunks.map(async ({ dataHash, minByteRange, maxByteRange }) => {\n        return {\n            type: \"leaf\",\n            id: await hash(await Promise.all([hash(dataHash), hash(intToBuffer(maxByteRange))])),\n            dataHash: dataHash,\n            minByteRange,\n            maxByteRange,\n        };\n    }));\n}\n/**\n * Builds an arweave merkle tree and gets the root hash for the given input.\n */\nasync function computeRootHash(data) {\n    const rootNode = await generateTree(data);\n    return rootNode.id;\n}\nasync function generateTree(data) {\n    const rootNode = await buildLayers(await generateLeaves(await chunkData(data)));\n    return rootNode;\n}\n/**\n * Generates the data_root, chunks & proofs\n * needed for a transaction.\n *\n * This also checks if the last chunk is a zero-length\n * chunk and discards that chunk and proof if so.\n * (we do not need to upload this zero length chunk)\n *\n * @param data\n */\nasync function generateTransactionChunks(data) {\n    const chunks = await chunkData(data);\n    const leaves = await generateLeaves(chunks);\n    const root = await buildLayers(leaves);\n    const proofs = await generateProofs(root);\n    // Discard the last chunk & proof if it's zero length.\n    const lastChunk = chunks.slice(-1)[0];\n    if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {\n        chunks.splice(chunks.length - 1, 1);\n        proofs.splice(proofs.length - 1, 1);\n    }\n    return {\n        data_root: root.id,\n        chunks,\n        proofs,\n    };\n}\n/**\n * Starting with the bottom layer of leaf nodes, hash every second pair\n * into a new branch node, push those branch nodes onto a new layer,\n * and then recurse, building up the tree to it's root, where the\n * layer only consists of two items.\n */\nasync function buildLayers(nodes, level = 0) {\n    // If there is only 1 node left, this is going to be the root node\n    if (nodes.length < 2) {\n        const root = nodes[0];\n        // console.log(\"Root layer\", root);\n        return root;\n    }\n    const nextLayer = [];\n    for (let i = 0; i < nodes.length; i += 2) {\n        nextLayer.push(await hashBranch(nodes[i], nodes[i + 1]));\n    }\n    // console.log(\"Layer\", nextLayer);\n    return buildLayers(nextLayer, level + 1);\n}\n/**\n * Recursively search through all branches of the tree,\n * and generate a proof for each leaf node.\n */\nfunction generateProofs(root) {\n    const proofs = resolveBranchProofs(root);\n    if (!Array.isArray(proofs)) {\n        return [proofs];\n    }\n    return arrayFlatten(proofs);\n}\nfunction resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {\n    if (node.type == \"leaf\") {\n        return {\n            offset: node.maxByteRange - 1,\n            proof: (0, utils_1.concatBuffers)([\n                proof,\n                node.dataHash,\n                intToBuffer(node.maxByteRange),\n            ]),\n        };\n    }\n    if (node.type == \"branch\") {\n        const partialProof = (0, utils_1.concatBuffers)([\n            proof,\n            node.leftChild.id,\n            node.rightChild.id,\n            intToBuffer(node.byteRange),\n        ]);\n        return [\n            resolveBranchProofs(node.leftChild, partialProof, depth + 1),\n            resolveBranchProofs(node.rightChild, partialProof, depth + 1),\n        ];\n    }\n    throw new Error(`Unexpected node type`);\n}\nfunction arrayFlatten(input) {\n    const flat = [];\n    input.forEach((item) => {\n        if (Array.isArray(item)) {\n            flat.push(...arrayFlatten(item));\n        }\n        else {\n            flat.push(item);\n        }\n    });\n    return flat;\n}\nasync function hashBranch(left, right) {\n    if (!right) {\n        return left;\n    }\n    let branch = {\n        type: \"branch\",\n        id: await hash([\n            await hash(left.id),\n            await hash(right.id),\n            await hash(intToBuffer(left.maxByteRange)),\n        ]),\n        byteRange: left.maxByteRange,\n        maxByteRange: right.maxByteRange,\n        leftChild: left,\n        rightChild: right,\n    };\n    return branch;\n}\nasync function hash(data) {\n    if (Array.isArray(data)) {\n        data = common_1.default.utils.concatBuffers(data);\n    }\n    return new Uint8Array(await common_1.default.crypto.hash(data));\n}\nfunction intToBuffer(note) {\n    const buffer = new Uint8Array(NOTE_SIZE);\n    for (var i = buffer.length - 1; i >= 0; i--) {\n        var byte = note % 256;\n        buffer[i] = byte;\n        note = (note - byte) / 256;\n    }\n    return buffer;\n}\nfunction bufferToInt(buffer) {\n    let value = 0;\n    for (var i = 0; i < buffer.length; i++) {\n        value *= 256;\n        value += buffer[i];\n    }\n    return value;\n}\nconst arrayCompare = (a, b) => a.every((value, index) => b[index] === value);\nexports.arrayCompare = arrayCompare;\nasync function validatePath(id, dest, leftBound, rightBound, path) {\n    if (rightBound <= 0) {\n        return false;\n    }\n    if (dest >= rightBound) {\n        return validatePath(id, 0, rightBound - 1, rightBound, path);\n    }\n    if (dest < 0) {\n        return validatePath(id, 0, 0, rightBound, path);\n    }\n    if (path.length == HASH_SIZE + NOTE_SIZE) {\n        const pathData = path.slice(0, HASH_SIZE);\n        const endOffsetBuffer = path.slice(pathData.length, pathData.length + NOTE_SIZE);\n        const pathDataHash = await hash([\n            await hash(pathData),\n            await hash(endOffsetBuffer),\n        ]);\n        let result = (0, exports.arrayCompare)(id, pathDataHash);\n        if (result) {\n            return {\n                offset: rightBound - 1,\n                leftBound: leftBound,\n                rightBound: rightBound,\n                chunkSize: rightBound - leftBound,\n            };\n        }\n        return false;\n    }\n    const left = path.slice(0, HASH_SIZE);\n    const right = path.slice(left.length, left.length + HASH_SIZE);\n    const offsetBuffer = path.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n    const offset = bufferToInt(offsetBuffer);\n    const remainder = path.slice(left.length + right.length + offsetBuffer.length);\n    const pathHash = await hash([\n        await hash(left),\n        await hash(right),\n        await hash(offsetBuffer),\n    ]);\n    if ((0, exports.arrayCompare)(id, pathHash)) {\n        if (dest < offset) {\n            return await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);\n        }\n        return await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);\n    }\n    return false;\n}\n/**\n * Inspect an arweave chunk proof.\n * Takes proof, parses, reads and displays the values for console logging.\n * One proof section per line\n * Format: left,right,offset => hash\n */\nasync function debug(proof, output = \"\") {\n    if (proof.byteLength < 1) {\n        return output;\n    }\n    const left = proof.slice(0, HASH_SIZE);\n    const right = proof.slice(left.length, left.length + HASH_SIZE);\n    const offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);\n    const offset = bufferToInt(offsetBuffer);\n    const remainder = proof.slice(left.length + right.length + offsetBuffer.length);\n    const pathHash = await hash([\n        await hash(left),\n        await hash(right),\n        await hash(offsetBuffer),\n    ]);\n    const updatedOutput = `${output}\\n${JSON.stringify(Buffer.from(left))},${JSON.stringify(Buffer.from(right))},${offset} => ${JSON.stringify(pathHash)}`;\n    return debug(remainder, updatedOutput);\n}\n//# sourceMappingURL=merkle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2xpYi9tZXJrbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0I7QUFDdEUsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCLGlDQUFpQztBQUNqQyxtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQ0FBaUMsbUJBQU8sQ0FBQyw4REFBVztBQUNwRCxnQkFBZ0IsbUJBQU8sQ0FBQywrREFBUztBQUNqQyxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxlQUFlLGlCQUFpQixlQUFlLHlCQUF5QixXQUFXLE9BQU8saUJBQWlCO0FBQzdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxJQUFJLGtDQUFrQyxHQUFHLG1DQUFtQyxHQUFHLFFBQVEsS0FBSyx5QkFBeUI7QUFDeko7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvd2FsaS9Eb3dubG9hZHMvcm91bGV0dGUgL25vZGVfbW9kdWxlcy9hcndlYXZlL25vZGUvbGliL21lcmtsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXJyYXlDb21wYXJlID0gZXhwb3J0cy5NSU5fQ0hVTktfU0laRSA9IGV4cG9ydHMuTUFYX0NIVU5LX1NJWkUgPSB2b2lkIDA7XG5leHBvcnRzLmNodW5rRGF0YSA9IGNodW5rRGF0YTtcbmV4cG9ydHMuZ2VuZXJhdGVMZWF2ZXMgPSBnZW5lcmF0ZUxlYXZlcztcbmV4cG9ydHMuY29tcHV0ZVJvb3RIYXNoID0gY29tcHV0ZVJvb3RIYXNoO1xuZXhwb3J0cy5nZW5lcmF0ZVRyZWUgPSBnZW5lcmF0ZVRyZWU7XG5leHBvcnRzLmdlbmVyYXRlVHJhbnNhY3Rpb25DaHVua3MgPSBnZW5lcmF0ZVRyYW5zYWN0aW9uQ2h1bmtzO1xuZXhwb3J0cy5idWlsZExheWVycyA9IGJ1aWxkTGF5ZXJzO1xuZXhwb3J0cy5nZW5lcmF0ZVByb29mcyA9IGdlbmVyYXRlUHJvb2ZzO1xuZXhwb3J0cy5hcnJheUZsYXR0ZW4gPSBhcnJheUZsYXR0ZW47XG5leHBvcnRzLmludFRvQnVmZmVyID0gaW50VG9CdWZmZXI7XG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gYnVmZmVyVG9JbnQ7XG5leHBvcnRzLnZhbGlkYXRlUGF0aCA9IHZhbGlkYXRlUGF0aDtcbmV4cG9ydHMuZGVidWcgPSBkZWJ1Zztcbi8qKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0Fyd2VhdmVUZWFtL2Fyd2VhdmUvYmxvYi9mYmMzODFlMGUzNmVmZmZhNDVkMTNmMmZhYTYxOTlkMzc2NmVkYWEyL2FwcHMvYXJ3ZWF2ZS9zcmMvYXJfbWVya2xlLmVybH1cbiAqL1xuY29uc3QgY29tbW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2NvbW1vblwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5leHBvcnRzLk1BWF9DSFVOS19TSVpFID0gMjU2ICogMTAyNDtcbmV4cG9ydHMuTUlOX0NIVU5LX1NJWkUgPSAzMiAqIDEwMjQ7XG5jb25zdCBOT1RFX1NJWkUgPSAzMjtcbmNvbnN0IEhBU0hfU0laRSA9IDMyO1xuLyoqXG4gKiBUYWtlcyB0aGUgaW5wdXQgZGF0YSBhbmQgY2h1bmtzIGl0IGludG8gKG1vc3RseSkgZXF1YWwgc2l6ZWQgY2h1bmtzLlxuICogVGhlIGxhc3QgY2h1bmsgd2lsbCBiZSBhIGJpdCBzbWFsbGVyIGFzIGl0IGNvbnRhaW5zIHRoZSByZW1haW5kZXJcbiAqIGZyb20gdGhlIGNodW5raW5nIHByb2Nlc3MuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNodW5rRGF0YShkYXRhKSB7XG4gICAgbGV0IGNodW5rcyA9IFtdO1xuICAgIGxldCByZXN0ID0gZGF0YTtcbiAgICBsZXQgY3Vyc29yID0gMDtcbiAgICB3aGlsZSAocmVzdC5ieXRlTGVuZ3RoID49IGV4cG9ydHMuTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgbGV0IGNodW5rU2l6ZSA9IGV4cG9ydHMuTUFYX0NIVU5LX1NJWkU7XG4gICAgICAgIC8vIElmIHRoZSB0b3RhbCBieXRlcyBsZWZ0IHdpbGwgcHJvZHVjZSBhIGNodW5rIDwgTUlOX0NIVU5LX1NJWkUsXG4gICAgICAgIC8vIHRoZW4gYWRqdXN0IHRoZSBhbW91bnQgd2UgcHV0IGluIHRoaXMgMm5kIGxhc3QgY2h1bmsuXG4gICAgICAgIGxldCBuZXh0Q2h1bmtTaXplID0gcmVzdC5ieXRlTGVuZ3RoIC0gZXhwb3J0cy5NQVhfQ0hVTktfU0laRTtcbiAgICAgICAgaWYgKG5leHRDaHVua1NpemUgPiAwICYmIG5leHRDaHVua1NpemUgPCBleHBvcnRzLk1JTl9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBjaHVua1NpemUgPSBNYXRoLmNlaWwocmVzdC5ieXRlTGVuZ3RoIC8gMik7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgTGFzdCBjaHVuayB3aWxsIGJlOiAke25leHRDaHVua1NpemV9IHdoaWNoIGlzIGJlbG93ICR7TUlOX0NIVU5LX1NJWkV9LCBhZGp1c3RpbmcgY3VycmVudCB0byAke2NodW5rU2l6ZX0gd2l0aCAke3Jlc3QuYnl0ZUxlbmd0aH0gbGVmdC5gKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNodW5rID0gcmVzdC5zbGljZSgwLCBjaHVua1NpemUpO1xuICAgICAgICBjb25zdCBkYXRhSGFzaCA9IGF3YWl0IGNvbW1vbl8xLmRlZmF1bHQuY3J5cHRvLmhhc2goY2h1bmspO1xuICAgICAgICBjdXJzb3IgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgY2h1bmtzLnB1c2goe1xuICAgICAgICAgICAgZGF0YUhhc2gsXG4gICAgICAgICAgICBtaW5CeXRlUmFuZ2U6IGN1cnNvciAtIGNodW5rLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBtYXhCeXRlUmFuZ2U6IGN1cnNvcixcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGNodW5rU2l6ZSk7XG4gICAgfVxuICAgIGNodW5rcy5wdXNoKHtcbiAgICAgICAgZGF0YUhhc2g6IGF3YWl0IGNvbW1vbl8xLmRlZmF1bHQuY3J5cHRvLmhhc2gocmVzdCksXG4gICAgICAgIG1pbkJ5dGVSYW5nZTogY3Vyc29yLFxuICAgICAgICBtYXhCeXRlUmFuZ2U6IGN1cnNvciArIHJlc3QuYnl0ZUxlbmd0aCxcbiAgICB9KTtcbiAgICByZXR1cm4gY2h1bmtzO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVMZWF2ZXMoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGNodW5rcy5tYXAoYXN5bmMgKHsgZGF0YUhhc2gsIG1pbkJ5dGVSYW5nZSwgbWF4Qnl0ZVJhbmdlIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwibGVhZlwiLFxuICAgICAgICAgICAgaWQ6IGF3YWl0IGhhc2goYXdhaXQgUHJvbWlzZS5hbGwoW2hhc2goZGF0YUhhc2gpLCBoYXNoKGludFRvQnVmZmVyKG1heEJ5dGVSYW5nZSkpXSkpLFxuICAgICAgICAgICAgZGF0YUhhc2g6IGRhdGFIYXNoLFxuICAgICAgICAgICAgbWluQnl0ZVJhbmdlLFxuICAgICAgICAgICAgbWF4Qnl0ZVJhbmdlLFxuICAgICAgICB9O1xuICAgIH0pKTtcbn1cbi8qKlxuICogQnVpbGRzIGFuIGFyd2VhdmUgbWVya2xlIHRyZWUgYW5kIGdldHMgdGhlIHJvb3QgaGFzaCBmb3IgdGhlIGdpdmVuIGlucHV0LlxuICovXG5hc3luYyBmdW5jdGlvbiBjb21wdXRlUm9vdEhhc2goZGF0YSkge1xuICAgIGNvbnN0IHJvb3ROb2RlID0gYXdhaXQgZ2VuZXJhdGVUcmVlKGRhdGEpO1xuICAgIHJldHVybiByb290Tm9kZS5pZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVHJlZShkYXRhKSB7XG4gICAgY29uc3Qgcm9vdE5vZGUgPSBhd2FpdCBidWlsZExheWVycyhhd2FpdCBnZW5lcmF0ZUxlYXZlcyhhd2FpdCBjaHVua0RhdGEoZGF0YSkpKTtcbiAgICByZXR1cm4gcm9vdE5vZGU7XG59XG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgZGF0YV9yb290LCBjaHVua3MgJiBwcm9vZnNcbiAqIG5lZWRlZCBmb3IgYSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBUaGlzIGFsc28gY2hlY2tzIGlmIHRoZSBsYXN0IGNodW5rIGlzIGEgemVyby1sZW5ndGhcbiAqIGNodW5rIGFuZCBkaXNjYXJkcyB0aGF0IGNodW5rIGFuZCBwcm9vZiBpZiBzby5cbiAqICh3ZSBkbyBub3QgbmVlZCB0byB1cGxvYWQgdGhpcyB6ZXJvIGxlbmd0aCBjaHVuaylcbiAqXG4gKiBAcGFyYW0gZGF0YVxuICovXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRyYW5zYWN0aW9uQ2h1bmtzKGRhdGEpIHtcbiAgICBjb25zdCBjaHVua3MgPSBhd2FpdCBjaHVua0RhdGEoZGF0YSk7XG4gICAgY29uc3QgbGVhdmVzID0gYXdhaXQgZ2VuZXJhdGVMZWF2ZXMoY2h1bmtzKTtcbiAgICBjb25zdCByb290ID0gYXdhaXQgYnVpbGRMYXllcnMobGVhdmVzKTtcbiAgICBjb25zdCBwcm9vZnMgPSBhd2FpdCBnZW5lcmF0ZVByb29mcyhyb290KTtcbiAgICAvLyBEaXNjYXJkIHRoZSBsYXN0IGNodW5rICYgcHJvb2YgaWYgaXQncyB6ZXJvIGxlbmd0aC5cbiAgICBjb25zdCBsYXN0Q2h1bmsgPSBjaHVua3Muc2xpY2UoLTEpWzBdO1xuICAgIGlmIChsYXN0Q2h1bmsubWF4Qnl0ZVJhbmdlIC0gbGFzdENodW5rLm1pbkJ5dGVSYW5nZSA9PT0gMCkge1xuICAgICAgICBjaHVua3Muc3BsaWNlKGNodW5rcy5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgcHJvb2ZzLnNwbGljZShwcm9vZnMubGVuZ3RoIC0gMSwgMSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFfcm9vdDogcm9vdC5pZCxcbiAgICAgICAgY2h1bmtzLFxuICAgICAgICBwcm9vZnMsXG4gICAgfTtcbn1cbi8qKlxuICogU3RhcnRpbmcgd2l0aCB0aGUgYm90dG9tIGxheWVyIG9mIGxlYWYgbm9kZXMsIGhhc2ggZXZlcnkgc2Vjb25kIHBhaXJcbiAqIGludG8gYSBuZXcgYnJhbmNoIG5vZGUsIHB1c2ggdGhvc2UgYnJhbmNoIG5vZGVzIG9udG8gYSBuZXcgbGF5ZXIsXG4gKiBhbmQgdGhlbiByZWN1cnNlLCBidWlsZGluZyB1cCB0aGUgdHJlZSB0byBpdCdzIHJvb3QsIHdoZXJlIHRoZVxuICogbGF5ZXIgb25seSBjb25zaXN0cyBvZiB0d28gaXRlbXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkTGF5ZXJzKG5vZGVzLCBsZXZlbCA9IDApIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IDEgbm9kZSBsZWZ0LCB0aGlzIGlzIGdvaW5nIHRvIGJlIHRoZSByb290IG5vZGVcbiAgICBpZiAobm9kZXMubGVuZ3RoIDwgMikge1xuICAgICAgICBjb25zdCByb290ID0gbm9kZXNbMF07XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiUm9vdCBsYXllclwiLCByb290KTtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIGNvbnN0IG5leHRMYXllciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgbmV4dExheWVyLnB1c2goYXdhaXQgaGFzaEJyYW5jaChub2Rlc1tpXSwgbm9kZXNbaSArIDFdKSk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKFwiTGF5ZXJcIiwgbmV4dExheWVyKTtcbiAgICByZXR1cm4gYnVpbGRMYXllcnMobmV4dExheWVyLCBsZXZlbCArIDEpO1xufVxuLyoqXG4gKiBSZWN1cnNpdmVseSBzZWFyY2ggdGhyb3VnaCBhbGwgYnJhbmNoZXMgb2YgdGhlIHRyZWUsXG4gKiBhbmQgZ2VuZXJhdGUgYSBwcm9vZiBmb3IgZWFjaCBsZWFmIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUHJvb2ZzKHJvb3QpIHtcbiAgICBjb25zdCBwcm9vZnMgPSByZXNvbHZlQnJhbmNoUHJvb2ZzKHJvb3QpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9vZnMpKSB7XG4gICAgICAgIHJldHVybiBbcHJvb2ZzXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5RmxhdHRlbihwcm9vZnMpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUJyYW5jaFByb29mcyhub2RlLCBwcm9vZiA9IG5ldyBVaW50OEFycmF5KCksIGRlcHRoID0gMCkge1xuICAgIGlmIChub2RlLnR5cGUgPT0gXCJsZWFmXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9mZnNldDogbm9kZS5tYXhCeXRlUmFuZ2UgLSAxLFxuICAgICAgICAgICAgcHJvb2Y6ICgwLCB1dGlsc18xLmNvbmNhdEJ1ZmZlcnMpKFtcbiAgICAgICAgICAgICAgICBwcm9vZixcbiAgICAgICAgICAgICAgICBub2RlLmRhdGFIYXNoLFxuICAgICAgICAgICAgICAgIGludFRvQnVmZmVyKG5vZGUubWF4Qnl0ZVJhbmdlKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09IFwiYnJhbmNoXCIpIHtcbiAgICAgICAgY29uc3QgcGFydGlhbFByb29mID0gKDAsIHV0aWxzXzEuY29uY2F0QnVmZmVycykoW1xuICAgICAgICAgICAgcHJvb2YsXG4gICAgICAgICAgICBub2RlLmxlZnRDaGlsZC5pZCxcbiAgICAgICAgICAgIG5vZGUucmlnaHRDaGlsZC5pZCxcbiAgICAgICAgICAgIGludFRvQnVmZmVyKG5vZGUuYnl0ZVJhbmdlKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICByZXNvbHZlQnJhbmNoUHJvb2ZzKG5vZGUubGVmdENoaWxkLCBwYXJ0aWFsUHJvb2YsIGRlcHRoICsgMSksXG4gICAgICAgICAgICByZXNvbHZlQnJhbmNoUHJvb2ZzKG5vZGUucmlnaHRDaGlsZCwgcGFydGlhbFByb29mLCBkZXB0aCArIDEpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgbm9kZSB0eXBlYCk7XG59XG5mdW5jdGlvbiBhcnJheUZsYXR0ZW4oaW5wdXQpIHtcbiAgICBjb25zdCBmbGF0ID0gW107XG4gICAgaW5wdXQuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgZmxhdC5wdXNoKC4uLmFycmF5RmxhdHRlbihpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbGF0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmxhdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhc2hCcmFuY2gobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoIXJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH1cbiAgICBsZXQgYnJhbmNoID0ge1xuICAgICAgICB0eXBlOiBcImJyYW5jaFwiLFxuICAgICAgICBpZDogYXdhaXQgaGFzaChbXG4gICAgICAgICAgICBhd2FpdCBoYXNoKGxlZnQuaWQpLFxuICAgICAgICAgICAgYXdhaXQgaGFzaChyaWdodC5pZCksXG4gICAgICAgICAgICBhd2FpdCBoYXNoKGludFRvQnVmZmVyKGxlZnQubWF4Qnl0ZVJhbmdlKSksXG4gICAgICAgIF0pLFxuICAgICAgICBieXRlUmFuZ2U6IGxlZnQubWF4Qnl0ZVJhbmdlLFxuICAgICAgICBtYXhCeXRlUmFuZ2U6IHJpZ2h0Lm1heEJ5dGVSYW5nZSxcbiAgICAgICAgbGVmdENoaWxkOiBsZWZ0LFxuICAgICAgICByaWdodENoaWxkOiByaWdodCxcbiAgICB9O1xuICAgIHJldHVybiBicmFuY2g7XG59XG5hc3luYyBmdW5jdGlvbiBoYXNoKGRhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhID0gY29tbW9uXzEuZGVmYXVsdC51dGlscy5jb25jYXRCdWZmZXJzKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgY29tbW9uXzEuZGVmYXVsdC5jcnlwdG8uaGFzaChkYXRhKSk7XG59XG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihub3RlKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoTk9URV9TSVpFKTtcbiAgICBmb3IgKHZhciBpID0gYnVmZmVyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBieXRlID0gbm90ZSAlIDI1NjtcbiAgICAgICAgYnVmZmVyW2ldID0gYnl0ZTtcbiAgICAgICAgbm90ZSA9IChub3RlIC0gYnl0ZSkgLyAyNTY7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5mdW5jdGlvbiBidWZmZXJUb0ludChidWZmZXIpIHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlICo9IDI1NjtcbiAgICAgICAgdmFsdWUgKz0gYnVmZmVyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBhcnJheUNvbXBhcmUgPSAoYSwgYikgPT4gYS5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiBiW2luZGV4XSA9PT0gdmFsdWUpO1xuZXhwb3J0cy5hcnJheUNvbXBhcmUgPSBhcnJheUNvbXBhcmU7XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVBhdGgoaWQsIGRlc3QsIGxlZnRCb3VuZCwgcmlnaHRCb3VuZCwgcGF0aCkge1xuICAgIGlmIChyaWdodEJvdW5kIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGVzdCA+PSByaWdodEJvdW5kKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVBhdGgoaWQsIDAsIHJpZ2h0Qm91bmQgLSAxLCByaWdodEJvdW5kLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKGRlc3QgPCAwKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVBhdGgoaWQsIDAsIDAsIHJpZ2h0Qm91bmQsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAocGF0aC5sZW5ndGggPT0gSEFTSF9TSVpFICsgTk9URV9TSVpFKSB7XG4gICAgICAgIGNvbnN0IHBhdGhEYXRhID0gcGF0aC5zbGljZSgwLCBIQVNIX1NJWkUpO1xuICAgICAgICBjb25zdCBlbmRPZmZzZXRCdWZmZXIgPSBwYXRoLnNsaWNlKHBhdGhEYXRhLmxlbmd0aCwgcGF0aERhdGEubGVuZ3RoICsgTk9URV9TSVpFKTtcbiAgICAgICAgY29uc3QgcGF0aERhdGFIYXNoID0gYXdhaXQgaGFzaChbXG4gICAgICAgICAgICBhd2FpdCBoYXNoKHBhdGhEYXRhKSxcbiAgICAgICAgICAgIGF3YWl0IGhhc2goZW5kT2Zmc2V0QnVmZmVyKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCByZXN1bHQgPSAoMCwgZXhwb3J0cy5hcnJheUNvbXBhcmUpKGlkLCBwYXRoRGF0YUhhc2gpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9mZnNldDogcmlnaHRCb3VuZCAtIDEsXG4gICAgICAgICAgICAgICAgbGVmdEJvdW5kOiBsZWZ0Qm91bmQsXG4gICAgICAgICAgICAgICAgcmlnaHRCb3VuZDogcmlnaHRCb3VuZCxcbiAgICAgICAgICAgICAgICBjaHVua1NpemU6IHJpZ2h0Qm91bmQgLSBsZWZ0Qm91bmQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbGVmdCA9IHBhdGguc2xpY2UoMCwgSEFTSF9TSVpFKTtcbiAgICBjb25zdCByaWdodCA9IHBhdGguc2xpY2UobGVmdC5sZW5ndGgsIGxlZnQubGVuZ3RoICsgSEFTSF9TSVpFKTtcbiAgICBjb25zdCBvZmZzZXRCdWZmZXIgPSBwYXRoLnNsaWNlKGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoLCBsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aCArIE5PVEVfU0laRSk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gYnVmZmVyVG9JbnQob2Zmc2V0QnVmZmVyKTtcbiAgICBjb25zdCByZW1haW5kZXIgPSBwYXRoLnNsaWNlKGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoICsgb2Zmc2V0QnVmZmVyLmxlbmd0aCk7XG4gICAgY29uc3QgcGF0aEhhc2ggPSBhd2FpdCBoYXNoKFtcbiAgICAgICAgYXdhaXQgaGFzaChsZWZ0KSxcbiAgICAgICAgYXdhaXQgaGFzaChyaWdodCksXG4gICAgICAgIGF3YWl0IGhhc2gob2Zmc2V0QnVmZmVyKSxcbiAgICBdKTtcbiAgICBpZiAoKDAsIGV4cG9ydHMuYXJyYXlDb21wYXJlKShpZCwgcGF0aEhhc2gpKSB7XG4gICAgICAgIGlmIChkZXN0IDwgb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdmFsaWRhdGVQYXRoKGxlZnQsIGRlc3QsIGxlZnRCb3VuZCwgTWF0aC5taW4ocmlnaHRCb3VuZCwgb2Zmc2V0KSwgcmVtYWluZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdmFsaWRhdGVQYXRoKHJpZ2h0LCBkZXN0LCBNYXRoLm1heChsZWZ0Qm91bmQsIG9mZnNldCksIHJpZ2h0Qm91bmQsIHJlbWFpbmRlcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogSW5zcGVjdCBhbiBhcndlYXZlIGNodW5rIHByb29mLlxuICogVGFrZXMgcHJvb2YsIHBhcnNlcywgcmVhZHMgYW5kIGRpc3BsYXlzIHRoZSB2YWx1ZXMgZm9yIGNvbnNvbGUgbG9nZ2luZy5cbiAqIE9uZSBwcm9vZiBzZWN0aW9uIHBlciBsaW5lXG4gKiBGb3JtYXQ6IGxlZnQscmlnaHQsb2Zmc2V0ID0+IGhhc2hcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVidWcocHJvb2YsIG91dHB1dCA9IFwiXCIpIHtcbiAgICBpZiAocHJvb2YuYnl0ZUxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgY29uc3QgbGVmdCA9IHByb29mLnNsaWNlKDAsIEhBU0hfU0laRSk7XG4gICAgY29uc3QgcmlnaHQgPSBwcm9vZi5zbGljZShsZWZ0Lmxlbmd0aCwgbGVmdC5sZW5ndGggKyBIQVNIX1NJWkUpO1xuICAgIGNvbnN0IG9mZnNldEJ1ZmZlciA9IHByb29mLnNsaWNlKGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoLCBsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aCArIE5PVEVfU0laRSk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gYnVmZmVyVG9JbnQob2Zmc2V0QnVmZmVyKTtcbiAgICBjb25zdCByZW1haW5kZXIgPSBwcm9vZi5zbGljZShsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aCArIG9mZnNldEJ1ZmZlci5sZW5ndGgpO1xuICAgIGNvbnN0IHBhdGhIYXNoID0gYXdhaXQgaGFzaChbXG4gICAgICAgIGF3YWl0IGhhc2gobGVmdCksXG4gICAgICAgIGF3YWl0IGhhc2gocmlnaHQpLFxuICAgICAgICBhd2FpdCBoYXNoKG9mZnNldEJ1ZmZlciksXG4gICAgXSk7XG4gICAgY29uc3QgdXBkYXRlZE91dHB1dCA9IGAke291dHB1dH1cXG4ke0pTT04uc3RyaW5naWZ5KEJ1ZmZlci5mcm9tKGxlZnQpKX0sJHtKU09OLnN0cmluZ2lmeShCdWZmZXIuZnJvbShyaWdodCkpfSwke29mZnNldH0gPT4gJHtKU09OLnN0cmluZ2lmeShwYXRoSGFzaCl9YDtcbiAgICByZXR1cm4gZGVidWcocmVtYWluZGVyLCB1cGRhdGVkT3V0cHV0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmtsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/lib/merkle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/lib/transaction-uploader.js":
/*!***************************************************************!*\
  !*** ./node_modules/arweave/node/lib/transaction-uploader.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TransactionUploader = void 0;\nconst transaction_1 = __importDefault(__webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/arweave/node/lib/transaction.js\"));\nconst ArweaveUtils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/arweave/node/lib/utils.js\"));\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/arweave/node/lib/error.js\");\nconst merkle_1 = __webpack_require__(/*! ./merkle */ \"(ssr)/./node_modules/arweave/node/lib/merkle.js\");\n// Maximum amount of chunks we will upload in the body.\nconst MAX_CHUNKS_IN_BODY = 1;\n// We assume these errors are intermitment and we can try again after a delay:\n// - not_joined\n// - timeout\n// - data_root_not_found (we may have hit a node that just hasn't seen it yet)\n// - exceeds_disk_pool_size_limit\n// We also try again after any kind of unexpected network errors\n// Errors from /chunk we should never try and continue on.\nconst FATAL_CHUNK_UPLOAD_ERRORS = [\n    \"invalid_json\",\n    \"chunk_too_big\",\n    \"data_path_too_big\",\n    \"offset_too_big\",\n    \"data_size_too_big\",\n    \"chunk_proof_ratio_not_attractive\",\n    \"invalid_proof\",\n];\n// Amount we will delay on receiving an error response but do want to continue.\nconst ERROR_DELAY = 1000 * 40;\nclass TransactionUploader {\n    api;\n    chunkIndex = 0;\n    txPosted = false;\n    transaction;\n    lastRequestTimeEnd = 0;\n    totalErrors = 0; // Not serialized.\n    data;\n    lastResponseStatus = 0;\n    lastResponseError = \"\";\n    get isComplete() {\n        return (this.txPosted &&\n            this.chunkIndex === this.transaction.chunks.chunks.length);\n    }\n    get totalChunks() {\n        return this.transaction.chunks.chunks.length;\n    }\n    get uploadedChunks() {\n        return this.chunkIndex;\n    }\n    get pctComplete() {\n        return Math.trunc((this.uploadedChunks / this.totalChunks) * 100);\n    }\n    constructor(api, transaction) {\n        this.api = api;\n        if (!transaction.id) {\n            throw new Error(`Transaction is not signed`);\n        }\n        if (!transaction.chunks) {\n            throw new Error(`Transaction chunks not prepared`);\n        }\n        // Make a copy of transaction, zeroing the data so we can serialize.\n        this.data = transaction.data;\n        this.transaction = new transaction_1.default(Object.assign({}, transaction, { data: new Uint8Array(0) }));\n    }\n    /**\n     * Uploads the next part of the transaction.\n     * On the first call this posts the transaction\n     * itself and on any subsequent calls uploads the\n     * next chunk until it completes.\n     */\n    async uploadChunk(chunkIndex_) {\n        if (this.isComplete) {\n            throw new Error(`Upload is already complete`);\n        }\n        if (this.lastResponseError !== \"\") {\n            this.totalErrors++;\n        }\n        else {\n            this.totalErrors = 0;\n        }\n        // We have been trying for about an hour receiving an\n        // error every time, so eventually bail.\n        if (this.totalErrors === 100) {\n            throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);\n        }\n        let delay = this.lastResponseError === \"\"\n            ? 0\n            : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);\n        if (delay > 0) {\n            // Jitter delay bcoz networks, subtract up to 30% from 40 seconds\n            delay = delay - delay * Math.random() * 0.3;\n            await new Promise((res) => setTimeout(res, delay));\n        }\n        this.lastResponseError = \"\";\n        if (!this.txPosted) {\n            await this.postTransaction();\n            return;\n        }\n        if (chunkIndex_) {\n            this.chunkIndex = chunkIndex_;\n        }\n        const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data);\n        const chunkOk = await (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));\n        if (!chunkOk) {\n            throw new Error(`Unable to validate chunk ${this.chunkIndex}`);\n        }\n        // Catch network errors and turn them into objects with status -1 and an error message.\n        const resp = await this.api\n            .post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data))\n            .catch((e) => {\n            console.error(e.message);\n            return { status: -1, data: { error: e.message } };\n        });\n        this.lastRequestTimeEnd = Date.now();\n        this.lastResponseStatus = resp.status;\n        if (this.lastResponseStatus == 200) {\n            this.chunkIndex++;\n        }\n        else {\n            this.lastResponseError = (0, error_1.getError)(resp);\n            if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {\n                throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);\n            }\n        }\n    }\n    /**\n     * Reconstructs an upload from its serialized state and data.\n     * Checks if data matches the expected data_root.\n     *\n     * @param serialized\n     * @param data\n     */\n    static async fromSerialized(api, serialized, data) {\n        if (!serialized ||\n            typeof serialized.chunkIndex !== \"number\" ||\n            typeof serialized.transaction !== \"object\") {\n            throw new Error(`Serialized object does not match expected format.`);\n        }\n        // Everything looks ok, reconstruct the TransactionUpload,\n        // prepare the chunks again and verify the data_root matches\n        var transaction = new transaction_1.default(serialized.transaction);\n        if (!transaction.chunks) {\n            await transaction.prepareChunks(data);\n        }\n        const upload = new TransactionUploader(api, transaction);\n        // Copy the serialized upload information, and data passed in.\n        upload.chunkIndex = serialized.chunkIndex;\n        upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;\n        upload.lastResponseError = serialized.lastResponseError;\n        upload.lastResponseStatus = serialized.lastResponseStatus;\n        upload.txPosted = serialized.txPosted;\n        upload.data = data;\n        if (upload.transaction.data_root !== serialized.transaction.data_root) {\n            throw new Error(`Data mismatch: Uploader doesn't match provided data.`);\n        }\n        return upload;\n    }\n    /**\n     * Reconstruct an upload from the tx metadata, ie /tx/<id>.\n     *\n     * @param api\n     * @param id\n     * @param data\n     */\n    static async fromTransactionId(api, id) {\n        const resp = await api.get(`tx/${id}`);\n        if (resp.status !== 200) {\n            throw new Error(`Tx ${id} not found: ${resp.status}`);\n        }\n        const transaction = resp.data;\n        transaction.data = new Uint8Array(0);\n        const serialized = {\n            txPosted: true,\n            chunkIndex: 0,\n            lastResponseError: \"\",\n            lastRequestTimeEnd: 0,\n            lastResponseStatus: 0,\n            transaction,\n        };\n        return serialized;\n    }\n    toJSON() {\n        return {\n            chunkIndex: this.chunkIndex,\n            transaction: this.transaction,\n            lastRequestTimeEnd: this.lastRequestTimeEnd,\n            lastResponseStatus: this.lastResponseStatus,\n            lastResponseError: this.lastResponseError,\n            txPosted: this.txPosted,\n        };\n    }\n    // POST to /tx\n    async postTransaction() {\n        const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;\n        if (uploadInBody) {\n            // Post the transaction with data.\n            this.transaction.data = this.data;\n            const resp = await this.api.post(`tx`, this.transaction).catch((e) => {\n                console.error(e);\n                return { status: -1, data: { error: e.message } };\n            });\n            this.lastRequestTimeEnd = Date.now();\n            this.lastResponseStatus = resp.status;\n            this.transaction.data = new Uint8Array(0);\n            if (resp.status >= 200 && resp.status < 300) {\n                // We are complete.\n                this.txPosted = true;\n                this.chunkIndex = MAX_CHUNKS_IN_BODY;\n                return;\n            }\n            this.lastResponseError = (0, error_1.getError)(resp);\n            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n        }\n        // Post the transaction with no data.\n        const resp = await this.api.post(`tx`, this.transaction);\n        this.lastRequestTimeEnd = Date.now();\n        this.lastResponseStatus = resp.status;\n        if (!(resp.status >= 200 && resp.status < 300)) {\n            this.lastResponseError = (0, error_1.getError)(resp);\n            throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);\n        }\n        this.txPosted = true;\n    }\n}\nexports.TransactionUploader = TransactionUploader;\n//# sourceMappingURL=transaction-uploader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2xpYi90cmFuc2FjdGlvbi11cGxvYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0Isc0NBQXNDLG1CQUFPLENBQUMsMkVBQWU7QUFDN0Qsa0NBQWtDLG1CQUFPLENBQUMsK0RBQVM7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsK0RBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsaUVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGlCQUFpQix5QkFBeUI7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx3QkFBd0IsSUFBSSx1QkFBdUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxnQkFBZ0IsSUFBSSx1QkFBdUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QztBQUNBLGtDQUFrQyxJQUFJLGFBQWEsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFlBQVksSUFBSSx1QkFBdUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsWUFBWSxJQUFJLHVCQUF1QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbGkvRG93bmxvYWRzL3JvdWxldHRlIC9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2xpYi90cmFuc2FjdGlvbi11cGxvYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc2FjdGlvblVwbG9hZGVyID0gdm9pZCAwO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKSk7XG5jb25zdCBBcndlYXZlVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuY29uc3QgbWVya2xlXzEgPSByZXF1aXJlKFwiLi9tZXJrbGVcIik7XG4vLyBNYXhpbXVtIGFtb3VudCBvZiBjaHVua3Mgd2Ugd2lsbCB1cGxvYWQgaW4gdGhlIGJvZHkuXG5jb25zdCBNQVhfQ0hVTktTX0lOX0JPRFkgPSAxO1xuLy8gV2UgYXNzdW1lIHRoZXNlIGVycm9ycyBhcmUgaW50ZXJtaXRtZW50IGFuZCB3ZSBjYW4gdHJ5IGFnYWluIGFmdGVyIGEgZGVsYXk6XG4vLyAtIG5vdF9qb2luZWRcbi8vIC0gdGltZW91dFxuLy8gLSBkYXRhX3Jvb3Rfbm90X2ZvdW5kICh3ZSBtYXkgaGF2ZSBoaXQgYSBub2RlIHRoYXQganVzdCBoYXNuJ3Qgc2VlbiBpdCB5ZXQpXG4vLyAtIGV4Y2VlZHNfZGlza19wb29sX3NpemVfbGltaXRcbi8vIFdlIGFsc28gdHJ5IGFnYWluIGFmdGVyIGFueSBraW5kIG9mIHVuZXhwZWN0ZWQgbmV0d29yayBlcnJvcnNcbi8vIEVycm9ycyBmcm9tIC9jaHVuayB3ZSBzaG91bGQgbmV2ZXIgdHJ5IGFuZCBjb250aW51ZSBvbi5cbmNvbnN0IEZBVEFMX0NIVU5LX1VQTE9BRF9FUlJPUlMgPSBbXG4gICAgXCJpbnZhbGlkX2pzb25cIixcbiAgICBcImNodW5rX3Rvb19iaWdcIixcbiAgICBcImRhdGFfcGF0aF90b29fYmlnXCIsXG4gICAgXCJvZmZzZXRfdG9vX2JpZ1wiLFxuICAgIFwiZGF0YV9zaXplX3Rvb19iaWdcIixcbiAgICBcImNodW5rX3Byb29mX3JhdGlvX25vdF9hdHRyYWN0aXZlXCIsXG4gICAgXCJpbnZhbGlkX3Byb29mXCIsXG5dO1xuLy8gQW1vdW50IHdlIHdpbGwgZGVsYXkgb24gcmVjZWl2aW5nIGFuIGVycm9yIHJlc3BvbnNlIGJ1dCBkbyB3YW50IHRvIGNvbnRpbnVlLlxuY29uc3QgRVJST1JfREVMQVkgPSAxMDAwICogNDA7XG5jbGFzcyBUcmFuc2FjdGlvblVwbG9hZGVyIHtcbiAgICBhcGk7XG4gICAgY2h1bmtJbmRleCA9IDA7XG4gICAgdHhQb3N0ZWQgPSBmYWxzZTtcbiAgICB0cmFuc2FjdGlvbjtcbiAgICBsYXN0UmVxdWVzdFRpbWVFbmQgPSAwO1xuICAgIHRvdGFsRXJyb3JzID0gMDsgLy8gTm90IHNlcmlhbGl6ZWQuXG4gICAgZGF0YTtcbiAgICBsYXN0UmVzcG9uc2VTdGF0dXMgPSAwO1xuICAgIGxhc3RSZXNwb25zZUVycm9yID0gXCJcIjtcbiAgICBnZXQgaXNDb21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR4UG9zdGVkICYmXG4gICAgICAgICAgICB0aGlzLmNodW5rSW5kZXggPT09IHRoaXMudHJhbnNhY3Rpb24uY2h1bmtzLmNodW5rcy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXQgdG90YWxDaHVua3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLmNodW5rcy5jaHVua3MubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgdXBsb2FkZWRDaHVua3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNodW5rSW5kZXg7XG4gICAgfVxuICAgIGdldCBwY3RDb21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmMoKHRoaXMudXBsb2FkZWRDaHVua3MgLyB0aGlzLnRvdGFsQ2h1bmtzKSAqIDEwMCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGFwaSwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gaXMgbm90IHNpZ25lZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uY2h1bmtzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGNodW5rcyBub3QgcHJlcGFyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIGEgY29weSBvZiB0cmFuc2FjdGlvbiwgemVyb2luZyB0aGUgZGF0YSBzbyB3ZSBjYW4gc2VyaWFsaXplLlxuICAgICAgICB0aGlzLmRhdGEgPSB0cmFuc2FjdGlvbi5kYXRhO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uID0gbmV3IHRyYW5zYWN0aW9uXzEuZGVmYXVsdChPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbiwgeyBkYXRhOiBuZXcgVWludDhBcnJheSgwKSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIG5leHQgcGFydCBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogT24gdGhlIGZpcnN0IGNhbGwgdGhpcyBwb3N0cyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBpdHNlbGYgYW5kIG9uIGFueSBzdWJzZXF1ZW50IGNhbGxzIHVwbG9hZHMgdGhlXG4gICAgICogbmV4dCBjaHVuayB1bnRpbCBpdCBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkQ2h1bmsoY2h1bmtJbmRleF8pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVcGxvYWQgaXMgYWxyZWFkeSBjb21wbGV0ZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxhc3RSZXNwb25zZUVycm9yICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLnRvdGFsRXJyb3JzKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRvdGFsRXJyb3JzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIGJlZW4gdHJ5aW5nIGZvciBhYm91dCBhbiBob3VyIHJlY2VpdmluZyBhblxuICAgICAgICAvLyBlcnJvciBldmVyeSB0aW1lLCBzbyBldmVudHVhbGx5IGJhaWwuXG4gICAgICAgIGlmICh0aGlzLnRvdGFsRXJyb3JzID09PSAxMDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvbXBsZXRlIHVwbG9hZDogJHt0aGlzLmxhc3RSZXNwb25zZVN0YXR1c306ICR7dGhpcy5sYXN0UmVzcG9uc2VFcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVsYXkgPSB0aGlzLmxhc3RSZXNwb25zZUVycm9yID09PSBcIlwiXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogTWF0aC5tYXgodGhpcy5sYXN0UmVxdWVzdFRpbWVFbmQgKyBFUlJPUl9ERUxBWSAtIERhdGUubm93KCksIEVSUk9SX0RFTEFZKTtcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgLy8gSml0dGVyIGRlbGF5IGJjb3ogbmV0d29ya3MsIHN1YnRyYWN0IHVwIHRvIDMwJSBmcm9tIDQwIHNlY29uZHNcbiAgICAgICAgICAgIGRlbGF5ID0gZGVsYXkgLSBkZWxheSAqIE1hdGgucmFuZG9tKCkgKiAwLjM7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgZGVsYXkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RSZXNwb25zZUVycm9yID0gXCJcIjtcbiAgICAgICAgaWYgKCF0aGlzLnR4UG9zdGVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBvc3RUcmFuc2FjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVua0luZGV4Xykge1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4ID0gY2h1bmtJbmRleF87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLnRyYW5zYWN0aW9uLmdldENodW5rKGNodW5rSW5kZXhfIHx8IHRoaXMuY2h1bmtJbmRleCwgdGhpcy5kYXRhKTtcbiAgICAgICAgY29uc3QgY2h1bmtPayA9IGF3YWl0ICgwLCBtZXJrbGVfMS52YWxpZGF0ZVBhdGgpKHRoaXMudHJhbnNhY3Rpb24uY2h1bmtzLmRhdGFfcm9vdCwgcGFyc2VJbnQoY2h1bmsub2Zmc2V0KSwgMCwgcGFyc2VJbnQoY2h1bmsuZGF0YV9zaXplKSwgQXJ3ZWF2ZVV0aWxzLmI2NFVybFRvQnVmZmVyKGNodW5rLmRhdGFfcGF0aCkpO1xuICAgICAgICBpZiAoIWNodW5rT2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHZhbGlkYXRlIGNodW5rICR7dGhpcy5jaHVua0luZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhdGNoIG5ldHdvcmsgZXJyb3JzIGFuZCB0dXJuIHRoZW0gaW50byBvYmplY3RzIHdpdGggc3RhdHVzIC0xIGFuZCBhbiBlcnJvciBtZXNzYWdlLlxuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5hcGlcbiAgICAgICAgICAgIC5wb3N0KGBjaHVua2AsIHRoaXMudHJhbnNhY3Rpb24uZ2V0Q2h1bmsodGhpcy5jaHVua0luZGV4LCB0aGlzLmRhdGEpKVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IC0xLCBkYXRhOiB7IGVycm9yOiBlLm1lc3NhZ2UgfSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sYXN0UmVxdWVzdFRpbWVFbmQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmxhc3RSZXNwb25zZVN0YXR1cyA9IHJlc3Auc3RhdHVzO1xuICAgICAgICBpZiAodGhpcy5sYXN0UmVzcG9uc2VTdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlc3BvbnNlRXJyb3IgPSAoMCwgZXJyb3JfMS5nZXRFcnJvcikocmVzcCk7XG4gICAgICAgICAgICBpZiAoRkFUQUxfQ0hVTktfVVBMT0FEX0VSUk9SUy5pbmNsdWRlcyh0aGlzLmxhc3RSZXNwb25zZUVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmF0YWwgZXJyb3IgdXBsb2FkaW5nIGNodW5rICR7dGhpcy5jaHVua0luZGV4fTogJHt0aGlzLmxhc3RSZXNwb25zZUVycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29uc3RydWN0cyBhbiB1cGxvYWQgZnJvbSBpdHMgc2VyaWFsaXplZCBzdGF0ZSBhbmQgZGF0YS5cbiAgICAgKiBDaGVja3MgaWYgZGF0YSBtYXRjaGVzIHRoZSBleHBlY3RlZCBkYXRhX3Jvb3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VyaWFsaXplZFxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZyb21TZXJpYWxpemVkKGFwaSwgc2VyaWFsaXplZCwgZGF0YSkge1xuICAgICAgICBpZiAoIXNlcmlhbGl6ZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBzZXJpYWxpemVkLmNodW5rSW5kZXggIT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBzZXJpYWxpemVkLnRyYW5zYWN0aW9uICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcmlhbGl6ZWQgb2JqZWN0IGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIGZvcm1hdC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFdmVyeXRoaW5nIGxvb2tzIG9rLCByZWNvbnN0cnVjdCB0aGUgVHJhbnNhY3Rpb25VcGxvYWQsXG4gICAgICAgIC8vIHByZXBhcmUgdGhlIGNodW5rcyBhZ2FpbiBhbmQgdmVyaWZ5IHRoZSBkYXRhX3Jvb3QgbWF0Y2hlc1xuICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBuZXcgdHJhbnNhY3Rpb25fMS5kZWZhdWx0KHNlcmlhbGl6ZWQudHJhbnNhY3Rpb24pO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLmNodW5rcykge1xuICAgICAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb24ucHJlcGFyZUNodW5rcyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWQgPSBuZXcgVHJhbnNhY3Rpb25VcGxvYWRlcihhcGksIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgLy8gQ29weSB0aGUgc2VyaWFsaXplZCB1cGxvYWQgaW5mb3JtYXRpb24sIGFuZCBkYXRhIHBhc3NlZCBpbi5cbiAgICAgICAgdXBsb2FkLmNodW5rSW5kZXggPSBzZXJpYWxpemVkLmNodW5rSW5kZXg7XG4gICAgICAgIHVwbG9hZC5sYXN0UmVxdWVzdFRpbWVFbmQgPSBzZXJpYWxpemVkLmxhc3RSZXF1ZXN0VGltZUVuZDtcbiAgICAgICAgdXBsb2FkLmxhc3RSZXNwb25zZUVycm9yID0gc2VyaWFsaXplZC5sYXN0UmVzcG9uc2VFcnJvcjtcbiAgICAgICAgdXBsb2FkLmxhc3RSZXNwb25zZVN0YXR1cyA9IHNlcmlhbGl6ZWQubGFzdFJlc3BvbnNlU3RhdHVzO1xuICAgICAgICB1cGxvYWQudHhQb3N0ZWQgPSBzZXJpYWxpemVkLnR4UG9zdGVkO1xuICAgICAgICB1cGxvYWQuZGF0YSA9IGRhdGE7XG4gICAgICAgIGlmICh1cGxvYWQudHJhbnNhY3Rpb24uZGF0YV9yb290ICE9PSBzZXJpYWxpemVkLnRyYW5zYWN0aW9uLmRhdGFfcm9vdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhIG1pc21hdGNoOiBVcGxvYWRlciBkb2Vzbid0IG1hdGNoIHByb3ZpZGVkIGRhdGEuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwbG9hZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb25zdHJ1Y3QgYW4gdXBsb2FkIGZyb20gdGhlIHR4IG1ldGFkYXRhLCBpZSAvdHgvPGlkPi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcGlcbiAgICAgKiBAcGFyYW0gaWRcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tVHJhbnNhY3Rpb25JZChhcGksIGlkKSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBhcGkuZ2V0KGB0eC8ke2lkfWApO1xuICAgICAgICBpZiAocmVzcC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeCAke2lkfSBub3QgZm91bmQ6ICR7cmVzcC5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSByZXNwLmRhdGE7XG4gICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgICAgICAgIHR4UG9zdGVkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bmtJbmRleDogMCxcbiAgICAgICAgICAgIGxhc3RSZXNwb25zZUVycm9yOiBcIlwiLFxuICAgICAgICAgICAgbGFzdFJlcXVlc3RUaW1lRW5kOiAwLFxuICAgICAgICAgICAgbGFzdFJlc3BvbnNlU3RhdHVzOiAwLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaHVua0luZGV4OiB0aGlzLmNodW5rSW5kZXgsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdGhpcy50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIGxhc3RSZXF1ZXN0VGltZUVuZDogdGhpcy5sYXN0UmVxdWVzdFRpbWVFbmQsXG4gICAgICAgICAgICBsYXN0UmVzcG9uc2VTdGF0dXM6IHRoaXMubGFzdFJlc3BvbnNlU3RhdHVzLFxuICAgICAgICAgICAgbGFzdFJlc3BvbnNlRXJyb3I6IHRoaXMubGFzdFJlc3BvbnNlRXJyb3IsXG4gICAgICAgICAgICB0eFBvc3RlZDogdGhpcy50eFBvc3RlZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUE9TVCB0byAvdHhcbiAgICBhc3luYyBwb3N0VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHVwbG9hZEluQm9keSA9IHRoaXMudG90YWxDaHVua3MgPD0gTUFYX0NIVU5LU19JTl9CT0RZO1xuICAgICAgICBpZiAodXBsb2FkSW5Cb2R5KSB7XG4gICAgICAgICAgICAvLyBQb3N0IHRoZSB0cmFuc2FjdGlvbiB3aXRoIGRhdGEuXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5hcGkucG9zdChgdHhgLCB0aGlzLnRyYW5zYWN0aW9uKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAtMSwgZGF0YTogeyBlcnJvcjogZS5tZXNzYWdlIH0gfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVxdWVzdFRpbWVFbmQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVzcG9uc2VTdGF0dXMgPSByZXNwLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uZGF0YSA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICAgICAgaWYgKHJlc3Auc3RhdHVzID49IDIwMCAmJiByZXNwLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBjb21wbGV0ZS5cbiAgICAgICAgICAgICAgICB0aGlzLnR4UG9zdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rSW5kZXggPSBNQVhfQ0hVTktTX0lOX0JPRFk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXN0UmVzcG9uc2VFcnJvciA9ICgwLCBlcnJvcl8xLmdldEVycm9yKShyZXNwKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHVwbG9hZCB0cmFuc2FjdGlvbjogJHtyZXNwLnN0YXR1c30sICR7dGhpcy5sYXN0UmVzcG9uc2VFcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3N0IHRoZSB0cmFuc2FjdGlvbiB3aXRoIG5vIGRhdGEuXG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmFwaS5wb3N0KGB0eGAsIHRoaXMudHJhbnNhY3Rpb24pO1xuICAgICAgICB0aGlzLmxhc3RSZXF1ZXN0VGltZUVuZCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMubGFzdFJlc3BvbnNlU3RhdHVzID0gcmVzcC5zdGF0dXM7XG4gICAgICAgIGlmICghKHJlc3Auc3RhdHVzID49IDIwMCAmJiByZXNwLnN0YXR1cyA8IDMwMCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlc3BvbnNlRXJyb3IgPSAoMCwgZXJyb3JfMS5nZXRFcnJvcikocmVzcCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byB1cGxvYWQgdHJhbnNhY3Rpb246ICR7cmVzcC5zdGF0dXN9LCAke3RoaXMubGFzdFJlc3BvbnNlRXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eFBvc3RlZCA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvblVwbG9hZGVyID0gVHJhbnNhY3Rpb25VcGxvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLXVwbG9hZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/lib/transaction-uploader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/lib/transaction.js":
/*!******************************************************!*\
  !*** ./node_modules/arweave/node/lib/transaction.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tag = void 0;\nconst ArweaveUtils = __importStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/arweave/node/lib/utils.js\"));\nconst deepHash_1 = __importDefault(__webpack_require__(/*! ./deepHash */ \"(ssr)/./node_modules/arweave/node/lib/deepHash.js\"));\nconst merkle_1 = __webpack_require__(/*! ./merkle */ \"(ssr)/./node_modules/arweave/node/lib/merkle.js\");\nclass BaseObject {\n    get(field, options) {\n        if (!Object.getOwnPropertyNames(this).includes(field)) {\n            throw new Error(`Field \"${field}\" is not a property of the Arweave Transaction class.`);\n        }\n        // Handle fields that are Uint8Arrays.\n        // To maintain compat we encode them to b64url\n        // if decode option is not specificed.\n        if (this[field] instanceof Uint8Array) {\n            if (options && options.decode && options.string) {\n                return ArweaveUtils.bufferToString(this[field]);\n            }\n            if (options && options.decode && !options.string) {\n                return this[field];\n            }\n            return ArweaveUtils.bufferTob64Url(this[field]);\n        }\n        if (this[field] instanceof Array) {\n            if (options?.decode !== undefined || options?.string !== undefined) {\n                if (field === \"tags\") {\n                    console.warn(`Did you mean to use 'transaction[\"tags\"]' ?`);\n                }\n                throw new Error(`Cannot decode or stringify an array.`);\n            }\n            return this[field];\n        }\n        if (options && options.decode == true) {\n            if (options && options.string) {\n                return ArweaveUtils.b64UrlToString(this[field]);\n            }\n            return ArweaveUtils.b64UrlToBuffer(this[field]);\n        }\n        return this[field];\n    }\n}\nclass Tag extends BaseObject {\n    name;\n    value;\n    constructor(name, value, decode = false) {\n        super();\n        this.name = name;\n        this.value = value;\n    }\n}\nexports.Tag = Tag;\nclass Transaction extends BaseObject {\n    format = 2;\n    id = \"\";\n    last_tx = \"\";\n    owner = \"\";\n    tags = [];\n    target = \"\";\n    quantity = \"0\";\n    data_size = \"0\";\n    data = new Uint8Array();\n    data_root = \"\";\n    reward = \"0\";\n    signature = \"\";\n    // Computed when needed.\n    chunks;\n    constructor(attributes = {}) {\n        super();\n        Object.assign(this, attributes);\n        // If something passes in a Tx that has been toJSON'ed and back,\n        // or where the data was filled in from /tx/data endpoint.\n        // data will be b64url encoded, so decode it.\n        if (typeof this.data === \"string\") {\n            this.data = ArweaveUtils.b64UrlToBuffer(this.data);\n        }\n        if (attributes.tags) {\n            this.tags = attributes.tags.map((tag) => {\n                return new Tag(tag.name, tag.value);\n            });\n        }\n    }\n    addTag(name, value) {\n        this.tags.push(new Tag(ArweaveUtils.stringToB64Url(name), ArweaveUtils.stringToB64Url(value)));\n    }\n    toJSON() {\n        return {\n            format: this.format,\n            id: this.id,\n            last_tx: this.last_tx,\n            owner: this.owner,\n            tags: this.tags,\n            target: this.target,\n            quantity: this.quantity,\n            data: ArweaveUtils.bufferTob64Url(this.data),\n            data_size: this.data_size,\n            data_root: this.data_root,\n            data_tree: this.data_tree,\n            reward: this.reward,\n            signature: this.signature,\n        };\n    }\n    setOwner(owner) {\n        this.owner = owner;\n    }\n    setSignature({ id, owner, reward, tags, signature, }) {\n        this.id = id;\n        this.owner = owner;\n        if (reward)\n            this.reward = reward;\n        if (tags)\n            this.tags = tags;\n        this.signature = signature;\n    }\n    async prepareChunks(data) {\n        // Note: we *do not* use `this.data`, the caller may be\n        // operating on a transaction with an zero length data field.\n        // This function computes the chunks for the data passed in and\n        // assigns the result to this transaction. It should not read the\n        // data *from* this transaction.\n        if (!this.chunks && data.byteLength > 0) {\n            this.chunks = await (0, merkle_1.generateTransactionChunks)(data);\n            this.data_root = ArweaveUtils.bufferTob64Url(this.chunks.data_root);\n        }\n        if (!this.chunks && data.byteLength === 0) {\n            this.chunks = {\n                chunks: [],\n                data_root: new Uint8Array(),\n                proofs: [],\n            };\n            this.data_root = \"\";\n        }\n    }\n    // Returns a chunk in a format suitable for posting to /chunk.\n    // Similar to `prepareChunks()` this does not operate `this.data`,\n    // instead using the data passed in.\n    getChunk(idx, data) {\n        if (!this.chunks) {\n            throw new Error(`Chunks have not been prepared`);\n        }\n        const proof = this.chunks.proofs[idx];\n        const chunk = this.chunks.chunks[idx];\n        return {\n            data_root: this.data_root,\n            data_size: this.data_size,\n            data_path: ArweaveUtils.bufferTob64Url(proof.proof),\n            offset: proof.offset.toString(),\n            chunk: ArweaveUtils.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange)),\n        };\n    }\n    async getSignatureData() {\n        switch (this.format) {\n            case 1:\n                let tags = this.tags.reduce((accumulator, tag) => {\n                    return ArweaveUtils.concatBuffers([\n                        accumulator,\n                        tag.get(\"name\", { decode: true, string: false }),\n                        tag.get(\"value\", { decode: true, string: false }),\n                    ]);\n                }, new Uint8Array());\n                return ArweaveUtils.concatBuffers([\n                    this.get(\"owner\", { decode: true, string: false }),\n                    this.get(\"target\", { decode: true, string: false }),\n                    this.get(\"data\", { decode: true, string: false }),\n                    ArweaveUtils.stringToBuffer(this.quantity),\n                    ArweaveUtils.stringToBuffer(this.reward),\n                    this.get(\"last_tx\", { decode: true, string: false }),\n                    tags,\n                ]);\n            case 2:\n                if (!this.data_root) {\n                    await this.prepareChunks(this.data);\n                }\n                const tagList = this.tags.map((tag) => [\n                    tag.get(\"name\", { decode: true, string: false }),\n                    tag.get(\"value\", { decode: true, string: false }),\n                ]);\n                return await (0, deepHash_1.default)([\n                    ArweaveUtils.stringToBuffer(this.format.toString()),\n                    this.get(\"owner\", { decode: true, string: false }),\n                    this.get(\"target\", { decode: true, string: false }),\n                    ArweaveUtils.stringToBuffer(this.quantity),\n                    ArweaveUtils.stringToBuffer(this.reward),\n                    this.get(\"last_tx\", { decode: true, string: false }),\n                    tagList,\n                    ArweaveUtils.stringToBuffer(this.data_size),\n                    this.get(\"data_root\", { decode: true, string: false }),\n                ]);\n            default:\n                throw new Error(`Unexpected transaction format: ${this.format}`);\n        }\n    }\n}\nexports[\"default\"] = Transaction;\n//# sourceMappingURL=transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2xpYi90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXO0FBQ1gsa0NBQWtDLG1CQUFPLENBQUMsK0RBQVM7QUFDbkQsbUNBQW1DLG1CQUFPLENBQUMscUVBQVk7QUFDdkQsaUJBQWlCLG1CQUFPLENBQUMsaUVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUNBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkJBQTZCO0FBQ3ZFLDJDQUEyQyw2QkFBNkI7QUFDeEU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx3Q0FBd0MsNkJBQTZCO0FBQ3JFLHlDQUF5Qyw2QkFBNkI7QUFDdEUsdUNBQXVDLDZCQUE2QjtBQUNwRTtBQUNBO0FBQ0EsMENBQTBDLDZCQUE2QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2QkFBNkI7QUFDbkUsdUNBQXVDLDZCQUE2QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkJBQTZCO0FBQ3JFLHlDQUF5Qyw2QkFBNkI7QUFDdEU7QUFDQTtBQUNBLDBDQUEwQyw2QkFBNkI7QUFDdkU7QUFDQTtBQUNBLDRDQUE0Qyw2QkFBNkI7QUFDekU7QUFDQTtBQUNBLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YWxpL0Rvd25sb2Fkcy9yb3VsZXR0ZSAvbm9kZV9tb2R1bGVzL2Fyd2VhdmUvbm9kZS9saWIvdHJhbnNhY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGFnID0gdm9pZCAwO1xuY29uc3QgQXJ3ZWF2ZVV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IGRlZXBIYXNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZGVlcEhhc2hcIikpO1xuY29uc3QgbWVya2xlXzEgPSByZXF1aXJlKFwiLi9tZXJrbGVcIik7XG5jbGFzcyBCYXNlT2JqZWN0IHtcbiAgICBnZXQoZmllbGQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgXCIke2ZpZWxkfVwiIGlzIG5vdCBhIHByb3BlcnR5IG9mIHRoZSBBcndlYXZlIFRyYW5zYWN0aW9uIGNsYXNzLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBmaWVsZHMgdGhhdCBhcmUgVWludDhBcnJheXMuXG4gICAgICAgIC8vIFRvIG1haW50YWluIGNvbXBhdCB3ZSBlbmNvZGUgdGhlbSB0byBiNjR1cmxcbiAgICAgICAgLy8gaWYgZGVjb2RlIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWNlZC5cbiAgICAgICAgaWYgKHRoaXNbZmllbGRdIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWNvZGUgJiYgb3B0aW9ucy5zdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJ3ZWF2ZVV0aWxzLmJ1ZmZlclRvU3RyaW5nKHRoaXNbZmllbGRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVjb2RlICYmICFvcHRpb25zLnN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBcndlYXZlVXRpbHMuYnVmZmVyVG9iNjRVcmwodGhpc1tmaWVsZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW2ZpZWxkXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucz8uZGVjb2RlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucz8uc3RyaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgPT09IFwidGFnc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGlkIHlvdSBtZWFuIHRvIHVzZSAndHJhbnNhY3Rpb25bXCJ0YWdzXCJdJyA/YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRlY29kZSBvciBzdHJpbmdpZnkgYW4gYXJyYXkuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tmaWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWNvZGUgPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJ3ZWF2ZVV0aWxzLmI2NFVybFRvU3RyaW5nKHRoaXNbZmllbGRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBcndlYXZlVXRpbHMuYjY0VXJsVG9CdWZmZXIodGhpc1tmaWVsZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2ZpZWxkXTtcbiAgICB9XG59XG5jbGFzcyBUYWcgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgICBuYW1lO1xuICAgIHZhbHVlO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZhbHVlLCBkZWNvZGUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5UYWcgPSBUYWc7XG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIEJhc2VPYmplY3Qge1xuICAgIGZvcm1hdCA9IDI7XG4gICAgaWQgPSBcIlwiO1xuICAgIGxhc3RfdHggPSBcIlwiO1xuICAgIG93bmVyID0gXCJcIjtcbiAgICB0YWdzID0gW107XG4gICAgdGFyZ2V0ID0gXCJcIjtcbiAgICBxdWFudGl0eSA9IFwiMFwiO1xuICAgIGRhdGFfc2l6ZSA9IFwiMFwiO1xuICAgIGRhdGEgPSBuZXcgVWludDhBcnJheSgpO1xuICAgIGRhdGFfcm9vdCA9IFwiXCI7XG4gICAgcmV3YXJkID0gXCIwXCI7XG4gICAgc2lnbmF0dXJlID0gXCJcIjtcbiAgICAvLyBDb21wdXRlZCB3aGVuIG5lZWRlZC5cbiAgICBjaHVua3M7XG4gICAgY29uc3RydWN0b3IoYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgYXR0cmlidXRlcyk7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBwYXNzZXMgaW4gYSBUeCB0aGF0IGhhcyBiZWVuIHRvSlNPTidlZCBhbmQgYmFjayxcbiAgICAgICAgLy8gb3Igd2hlcmUgdGhlIGRhdGEgd2FzIGZpbGxlZCBpbiBmcm9tIC90eC9kYXRhIGVuZHBvaW50LlxuICAgICAgICAvLyBkYXRhIHdpbGwgYmUgYjY0dXJsIGVuY29kZWQsIHNvIGRlY29kZSBpdC5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IEFyd2VhdmVVdGlscy5iNjRVcmxUb0J1ZmZlcih0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLnRhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMudGFncyA9IGF0dHJpYnV0ZXMudGFncy5tYXAoKHRhZykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFnKHRhZy5uYW1lLCB0YWcudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFnKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGFncy5wdXNoKG5ldyBUYWcoQXJ3ZWF2ZVV0aWxzLnN0cmluZ1RvQjY0VXJsKG5hbWUpLCBBcndlYXZlVXRpbHMuc3RyaW5nVG9CNjRVcmwodmFsdWUpKSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5mb3JtYXQsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGxhc3RfdHg6IHRoaXMubGFzdF90eCxcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLm93bmVyLFxuICAgICAgICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgICAgICAgIHF1YW50aXR5OiB0aGlzLnF1YW50aXR5LFxuICAgICAgICAgICAgZGF0YTogQXJ3ZWF2ZVV0aWxzLmJ1ZmZlclRvYjY0VXJsKHRoaXMuZGF0YSksXG4gICAgICAgICAgICBkYXRhX3NpemU6IHRoaXMuZGF0YV9zaXplLFxuICAgICAgICAgICAgZGF0YV9yb290OiB0aGlzLmRhdGFfcm9vdCxcbiAgICAgICAgICAgIGRhdGFfdHJlZTogdGhpcy5kYXRhX3RyZWUsXG4gICAgICAgICAgICByZXdhcmQ6IHRoaXMucmV3YXJkLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB0aGlzLnNpZ25hdHVyZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0T3duZXIob3duZXIpIHtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIH1cbiAgICBzZXRTaWduYXR1cmUoeyBpZCwgb3duZXIsIHJld2FyZCwgdGFncywgc2lnbmF0dXJlLCB9KSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgICAgICBpZiAocmV3YXJkKVxuICAgICAgICAgICAgdGhpcy5yZXdhcmQgPSByZXdhcmQ7XG4gICAgICAgIGlmICh0YWdzKVxuICAgICAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVDaHVua3MoZGF0YSkge1xuICAgICAgICAvLyBOb3RlOiB3ZSAqZG8gbm90KiB1c2UgYHRoaXMuZGF0YWAsIHRoZSBjYWxsZXIgbWF5IGJlXG4gICAgICAgIC8vIG9wZXJhdGluZyBvbiBhIHRyYW5zYWN0aW9uIHdpdGggYW4gemVybyBsZW5ndGggZGF0YSBmaWVsZC5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjb21wdXRlcyB0aGUgY2h1bmtzIGZvciB0aGUgZGF0YSBwYXNzZWQgaW4gYW5kXG4gICAgICAgIC8vIGFzc2lnbnMgdGhlIHJlc3VsdCB0byB0aGlzIHRyYW5zYWN0aW9uLiBJdCBzaG91bGQgbm90IHJlYWQgdGhlXG4gICAgICAgIC8vIGRhdGEgKmZyb20qIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5jaHVua3MgJiYgZGF0YS5ieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jaHVua3MgPSBhd2FpdCAoMCwgbWVya2xlXzEuZ2VuZXJhdGVUcmFuc2FjdGlvbkNodW5rcykoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmRhdGFfcm9vdCA9IEFyd2VhdmVVdGlscy5idWZmZXJUb2I2NFVybCh0aGlzLmNodW5rcy5kYXRhX3Jvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jaHVua3MgJiYgZGF0YS5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rcyA9IHtcbiAgICAgICAgICAgICAgICBjaHVua3M6IFtdLFxuICAgICAgICAgICAgICAgIGRhdGFfcm9vdDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgICAgICBwcm9vZnM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZGF0YV9yb290ID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgY2h1bmsgaW4gYSBmb3JtYXQgc3VpdGFibGUgZm9yIHBvc3RpbmcgdG8gL2NodW5rLlxuICAgIC8vIFNpbWlsYXIgdG8gYHByZXBhcmVDaHVua3MoKWAgdGhpcyBkb2VzIG5vdCBvcGVyYXRlIGB0aGlzLmRhdGFgLFxuICAgIC8vIGluc3RlYWQgdXNpbmcgdGhlIGRhdGEgcGFzc2VkIGluLlxuICAgIGdldENodW5rKGlkeCwgZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuY2h1bmtzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENodW5rcyBoYXZlIG5vdCBiZWVuIHByZXBhcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvb2YgPSB0aGlzLmNodW5rcy5wcm9vZnNbaWR4XTtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLmNodW5rcy5jaHVua3NbaWR4XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFfcm9vdDogdGhpcy5kYXRhX3Jvb3QsXG4gICAgICAgICAgICBkYXRhX3NpemU6IHRoaXMuZGF0YV9zaXplLFxuICAgICAgICAgICAgZGF0YV9wYXRoOiBBcndlYXZlVXRpbHMuYnVmZmVyVG9iNjRVcmwocHJvb2YucHJvb2YpLFxuICAgICAgICAgICAgb2Zmc2V0OiBwcm9vZi5vZmZzZXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGNodW5rOiBBcndlYXZlVXRpbHMuYnVmZmVyVG9iNjRVcmwoZGF0YS5zbGljZShjaHVuay5taW5CeXRlUmFuZ2UsIGNodW5rLm1heEJ5dGVSYW5nZSkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRTaWduYXR1cmVEYXRhKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbGV0IHRhZ3MgPSB0aGlzLnRhZ3MucmVkdWNlKChhY2N1bXVsYXRvciwgdGFnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBcndlYXZlVXRpbHMuY29uY2F0QnVmZmVycyhbXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5nZXQoXCJuYW1lXCIsIHsgZGVjb2RlOiB0cnVlLCBzdHJpbmc6IGZhbHNlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnLmdldChcInZhbHVlXCIsIHsgZGVjb2RlOiB0cnVlLCBzdHJpbmc6IGZhbHNlIH0pLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9LCBuZXcgVWludDhBcnJheSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJ3ZWF2ZVV0aWxzLmNvbmNhdEJ1ZmZlcnMoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldChcIm93bmVyXCIsIHsgZGVjb2RlOiB0cnVlLCBzdHJpbmc6IGZhbHNlIH0pLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldChcInRhcmdldFwiLCB7IGRlY29kZTogdHJ1ZSwgc3RyaW5nOiBmYWxzZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXQoXCJkYXRhXCIsIHsgZGVjb2RlOiB0cnVlLCBzdHJpbmc6IGZhbHNlIH0pLFxuICAgICAgICAgICAgICAgICAgICBBcndlYXZlVXRpbHMuc3RyaW5nVG9CdWZmZXIodGhpcy5xdWFudGl0eSksXG4gICAgICAgICAgICAgICAgICAgIEFyd2VhdmVVdGlscy5zdHJpbmdUb0J1ZmZlcih0aGlzLnJld2FyZCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0KFwibGFzdF90eFwiLCB7IGRlY29kZTogdHJ1ZSwgc3RyaW5nOiBmYWxzZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgdGFncyxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGF0YV9yb290KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJlcGFyZUNodW5rcyh0aGlzLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0YWdMaXN0ID0gdGhpcy50YWdzLm1hcCgodGFnKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgIHRhZy5nZXQoXCJuYW1lXCIsIHsgZGVjb2RlOiB0cnVlLCBzdHJpbmc6IGZhbHNlIH0pLFxuICAgICAgICAgICAgICAgICAgICB0YWcuZ2V0KFwidmFsdWVcIiwgeyBkZWNvZGU6IHRydWUsIHN0cmluZzogZmFsc2UgfSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBkZWVwSGFzaF8xLmRlZmF1bHQpKFtcbiAgICAgICAgICAgICAgICAgICAgQXJ3ZWF2ZVV0aWxzLnN0cmluZ1RvQnVmZmVyKHRoaXMuZm9ybWF0LnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldChcIm93bmVyXCIsIHsgZGVjb2RlOiB0cnVlLCBzdHJpbmc6IGZhbHNlIH0pLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldChcInRhcmdldFwiLCB7IGRlY29kZTogdHJ1ZSwgc3RyaW5nOiBmYWxzZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgQXJ3ZWF2ZVV0aWxzLnN0cmluZ1RvQnVmZmVyKHRoaXMucXVhbnRpdHkpLFxuICAgICAgICAgICAgICAgICAgICBBcndlYXZlVXRpbHMuc3RyaW5nVG9CdWZmZXIodGhpcy5yZXdhcmQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldChcImxhc3RfdHhcIiwgeyBkZWNvZGU6IHRydWUsIHN0cmluZzogZmFsc2UgfSksXG4gICAgICAgICAgICAgICAgICAgIHRhZ0xpc3QsXG4gICAgICAgICAgICAgICAgICAgIEFyd2VhdmVVdGlscy5zdHJpbmdUb0J1ZmZlcih0aGlzLmRhdGFfc2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0KFwiZGF0YV9yb290XCIsIHsgZGVjb2RlOiB0cnVlLCBzdHJpbmc6IGZhbHNlIH0pLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHJhbnNhY3Rpb24gZm9ybWF0OiAke3RoaXMuZm9ybWF0fWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNhY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/lib/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/lib/utils.js":
/*!************************************************!*\
  !*** ./node_modules/arweave/node/lib/utils.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concatBuffers = concatBuffers;\nexports.b64UrlToString = b64UrlToString;\nexports.bufferToString = bufferToString;\nexports.stringToBuffer = stringToBuffer;\nexports.stringToB64Url = stringToB64Url;\nexports.b64UrlToBuffer = b64UrlToBuffer;\nexports.bufferTob64 = bufferTob64;\nexports.bufferTob64Url = bufferTob64Url;\nexports.b64UrlEncode = b64UrlEncode;\nexports.b64UrlDecode = b64UrlDecode;\nconst B64js = __importStar(__webpack_require__(/*! base64-js */ \"(ssr)/./node_modules/base64-js/index.js\"));\nfunction concatBuffers(buffers) {\n    let total_length = 0;\n    for (let i = 0; i < buffers.length; i++) {\n        total_length += buffers[i].byteLength;\n    }\n    let temp = new Uint8Array(total_length);\n    let offset = 0;\n    temp.set(new Uint8Array(buffers[0]), offset);\n    offset += buffers[0].byteLength;\n    for (let i = 1; i < buffers.length; i++) {\n        temp.set(new Uint8Array(buffers[i]), offset);\n        offset += buffers[i].byteLength;\n    }\n    return temp;\n}\nfunction b64UrlToString(b64UrlString) {\n    let buffer = b64UrlToBuffer(b64UrlString);\n    return bufferToString(buffer);\n}\nfunction bufferToString(buffer) {\n    return new TextDecoder(\"utf-8\", { fatal: true }).decode(buffer);\n}\nfunction stringToBuffer(string) {\n    return new TextEncoder().encode(string);\n}\nfunction stringToB64Url(string) {\n    return bufferTob64Url(stringToBuffer(string));\n}\nfunction b64UrlToBuffer(b64UrlString) {\n    return new Uint8Array(B64js.toByteArray(b64UrlDecode(b64UrlString)));\n}\nfunction bufferTob64(buffer) {\n    return B64js.fromByteArray(new Uint8Array(buffer));\n}\nfunction bufferTob64Url(buffer) {\n    return b64UrlEncode(bufferTob64(buffer));\n}\nfunction b64UrlEncode(b64UrlString) {\n    try {\n        return b64UrlString\n            .replace(/\\+/g, \"-\")\n            .replace(/\\//g, \"_\")\n            .replace(/\\=/g, \"\");\n    }\n    catch (error) {\n        throw new Error(\"Failed to encode string\", { cause: error });\n    }\n}\nfunction b64UrlDecode(b64UrlString) {\n    try {\n        b64UrlString = b64UrlString.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\");\n        let padding;\n        b64UrlString.length % 4 == 0\n            ? (padding = 0)\n            : (padding = 4 - (b64UrlString.length % 4));\n        return b64UrlString.concat(\"=\".repeat(padding));\n    }\n    catch (error) {\n        throw new Error(\"Failed to decode string\", { cause: error });\n    }\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLDJCQUEyQixtQkFBTyxDQUFDLDBEQUFXO0FBQzlDO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YWxpL0Rvd25sb2Fkcy9yb3VsZXR0ZSAvbm9kZV9tb2R1bGVzL2Fyd2VhdmUvbm9kZS9saWIvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29uY2F0QnVmZmVycyA9IGNvbmNhdEJ1ZmZlcnM7XG5leHBvcnRzLmI2NFVybFRvU3RyaW5nID0gYjY0VXJsVG9TdHJpbmc7XG5leHBvcnRzLmJ1ZmZlclRvU3RyaW5nID0gYnVmZmVyVG9TdHJpbmc7XG5leHBvcnRzLnN0cmluZ1RvQnVmZmVyID0gc3RyaW5nVG9CdWZmZXI7XG5leHBvcnRzLnN0cmluZ1RvQjY0VXJsID0gc3RyaW5nVG9CNjRVcmw7XG5leHBvcnRzLmI2NFVybFRvQnVmZmVyID0gYjY0VXJsVG9CdWZmZXI7XG5leHBvcnRzLmJ1ZmZlclRvYjY0ID0gYnVmZmVyVG9iNjQ7XG5leHBvcnRzLmJ1ZmZlclRvYjY0VXJsID0gYnVmZmVyVG9iNjRVcmw7XG5leHBvcnRzLmI2NFVybEVuY29kZSA9IGI2NFVybEVuY29kZTtcbmV4cG9ydHMuYjY0VXJsRGVjb2RlID0gYjY0VXJsRGVjb2RlO1xuY29uc3QgQjY0anMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImJhc2U2NC1qc1wiKSk7XG5mdW5jdGlvbiBjb25jYXRCdWZmZXJzKGJ1ZmZlcnMpIHtcbiAgICBsZXQgdG90YWxfbGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWxfbGVuZ3RoICs9IGJ1ZmZlcnNbaV0uYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgbGV0IHRlbXAgPSBuZXcgVWludDhBcnJheSh0b3RhbF9sZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHRlbXAuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlcnNbMF0pLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBidWZmZXJzWzBdLmJ5dGVMZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRlbXAuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlcnNbaV0pLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gYnVmZmVyc1tpXS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcDtcbn1cbmZ1bmN0aW9uIGI2NFVybFRvU3RyaW5nKGI2NFVybFN0cmluZykge1xuICAgIGxldCBidWZmZXIgPSBiNjRVcmxUb0J1ZmZlcihiNjRVcmxTdHJpbmcpO1xuICAgIHJldHVybiBidWZmZXJUb1N0cmluZyhidWZmZXIpO1xufVxuZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcoYnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIsIHsgZmF0YWw6IHRydWUgfSkuZGVjb2RlKGJ1ZmZlcik7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0J1ZmZlcihzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cmluZyk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0I2NFVybChzdHJpbmcpIHtcbiAgICByZXR1cm4gYnVmZmVyVG9iNjRVcmwoc3RyaW5nVG9CdWZmZXIoc3RyaW5nKSk7XG59XG5mdW5jdGlvbiBiNjRVcmxUb0J1ZmZlcihiNjRVcmxTdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQjY0anMudG9CeXRlQXJyYXkoYjY0VXJsRGVjb2RlKGI2NFVybFN0cmluZykpKTtcbn1cbmZ1bmN0aW9uIGJ1ZmZlclRvYjY0KGJ1ZmZlcikge1xuICAgIHJldHVybiBCNjRqcy5mcm9tQnl0ZUFycmF5KG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xufVxuZnVuY3Rpb24gYnVmZmVyVG9iNjRVcmwoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGI2NFVybEVuY29kZShidWZmZXJUb2I2NChidWZmZXIpKTtcbn1cbmZ1bmN0aW9uIGI2NFVybEVuY29kZShiNjRVcmxTdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYjY0VXJsU3RyaW5nXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwrL2csIFwiLVwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCBcIl9cIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXD0vZywgXCJcIik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZW5jb2RlIHN0cmluZ1wiLCB7IGNhdXNlOiBlcnJvciB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBiNjRVcmxEZWNvZGUoYjY0VXJsU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYjY0VXJsU3RyaW5nID0gYjY0VXJsU3RyaW5nLnJlcGxhY2UoL1xcLS9nLCBcIitcIikucmVwbGFjZSgvXFxfL2csIFwiL1wiKTtcbiAgICAgICAgbGV0IHBhZGRpbmc7XG4gICAgICAgIGI2NFVybFN0cmluZy5sZW5ndGggJSA0ID09IDBcbiAgICAgICAgICAgID8gKHBhZGRpbmcgPSAwKVxuICAgICAgICAgICAgOiAocGFkZGluZyA9IDQgLSAoYjY0VXJsU3RyaW5nLmxlbmd0aCAlIDQpKTtcbiAgICAgICAgcmV0dXJuIGI2NFVybFN0cmluZy5jb25jYXQoXCI9XCIucmVwZWF0KHBhZGRpbmcpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgc3RyaW5nXCIsIHsgY2F1c2U6IGVycm9yIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/network.js":
/*!**********************************************!*\
  !*** ./node_modules/arweave/node/network.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Network {\n    api;\n    constructor(api) {\n        this.api = api;\n    }\n    getInfo() {\n        return this.api.get(`info`).then((response) => {\n            return response.data;\n        });\n    }\n    getPeers() {\n        return this.api.get(`peers`).then((response) => {\n            return response.data;\n        });\n    }\n}\nexports[\"default\"] = Network;\n//# sourceMappingURL=network.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL25ldHdvcmsuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3dhbGkvRG93bmxvYWRzL3JvdWxldHRlIC9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL25ldHdvcmsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBOZXR3b3JrIHtcbiAgICBhcGk7XG4gICAgY29uc3RydWN0b3IoYXBpKSB7XG4gICAgICAgIHRoaXMuYXBpID0gYXBpO1xuICAgIH1cbiAgICBnZXRJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGkuZ2V0KGBpbmZvYCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5nZXQoYHBlZXJzYCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBOZXR3b3JrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29yay5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/network.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/silo.js":
/*!*******************************************!*\
  !*** ./node_modules/arweave/node/silo.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SiloResource = void 0;\nconst ArweaveUtils = __importStar(__webpack_require__(/*! ./lib/utils */ \"(ssr)/./node_modules/arweave/node/lib/utils.js\"));\nclass Silo {\n    api;\n    crypto;\n    transactions;\n    constructor(api, crypto, transactions) {\n        this.api = api;\n        this.crypto = crypto;\n        this.transactions = transactions;\n    }\n    async get(siloURI) {\n        if (!siloURI) {\n            throw new Error(`No Silo URI specified`);\n        }\n        const resource = await this.parseUri(siloURI);\n        const ids = await this.transactions.search(\"Silo-Name\", resource.getAccessKey());\n        if (ids.length == 0) {\n            throw new Error(`No data could be found for the Silo URI: ${siloURI}`);\n        }\n        const transaction = await this.transactions.get(ids[0]);\n        if (!transaction) {\n            throw new Error(`No data could be found for the Silo URI: ${siloURI}`);\n        }\n        const encrypted = transaction.get(\"data\", { decode: true, string: false });\n        return this.crypto.decrypt(encrypted, resource.getEncryptionKey());\n    }\n    async readTransactionData(transaction, siloURI) {\n        if (!siloURI) {\n            throw new Error(`No Silo URI specified`);\n        }\n        const resource = await this.parseUri(siloURI);\n        const encrypted = transaction.get(\"data\", { decode: true, string: false });\n        return this.crypto.decrypt(encrypted, resource.getEncryptionKey());\n    }\n    async parseUri(siloURI) {\n        const parsed = siloURI.match(/^([a-z0-9-_]+)\\.([0-9]+)/i);\n        if (!parsed) {\n            throw new Error(`Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'`);\n        }\n        const siloName = parsed[1];\n        const hashIterations = Math.pow(2, parseInt(parsed[2]));\n        const digest = await this.hash(ArweaveUtils.stringToBuffer(siloName), hashIterations);\n        const accessKey = ArweaveUtils.bufferTob64(digest.slice(0, 15));\n        const encryptionkey = await this.hash(digest.slice(16, 31), 1);\n        return new SiloResource(siloURI, accessKey, encryptionkey);\n    }\n    async hash(input, iterations) {\n        let digest = await this.crypto.hash(input);\n        for (let count = 0; count < iterations - 1; count++) {\n            digest = await this.crypto.hash(digest);\n        }\n        return digest;\n    }\n}\nexports[\"default\"] = Silo;\nclass SiloResource {\n    uri;\n    accessKey;\n    encryptionKey;\n    constructor(uri, accessKey, encryptionKey) {\n        this.uri = uri;\n        this.accessKey = accessKey;\n        this.encryptionKey = encryptionKey;\n    }\n    getUri() {\n        return this.uri;\n    }\n    getAccessKey() {\n        return this.accessKey;\n    }\n    getEncryptionKey() {\n        return this.encryptionKey;\n    }\n}\nexports.SiloResource = SiloResource;\n//# sourceMappingURL=silo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL3NpbG8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixrQ0FBa0MsbUJBQU8sQ0FBQyxtRUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxRQUFRO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxRQUFRO0FBQ2hGO0FBQ0Esb0RBQW9ELDZCQUE2QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCw2QkFBNkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyIvVXNlcnMvd2FsaS9Eb3dubG9hZHMvcm91bGV0dGUgL25vZGVfbW9kdWxlcy9hcndlYXZlL25vZGUvc2lsby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaWxvUmVzb3VyY2UgPSB2b2lkIDA7XG5jb25zdCBBcndlYXZlVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbGliL3V0aWxzXCIpKTtcbmNsYXNzIFNpbG8ge1xuICAgIGFwaTtcbiAgICBjcnlwdG87XG4gICAgdHJhbnNhY3Rpb25zO1xuICAgIGNvbnN0cnVjdG9yKGFwaSwgY3J5cHRvLCB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgICAgIHRoaXMuY3J5cHRvID0gY3J5cHRvO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucztcbiAgICB9XG4gICAgYXN5bmMgZ2V0KHNpbG9VUkkpIHtcbiAgICAgICAgaWYgKCFzaWxvVVJJKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIFNpbG8gVVJJIHNwZWNpZmllZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gYXdhaXQgdGhpcy5wYXJzZVVyaShzaWxvVVJJKTtcbiAgICAgICAgY29uc3QgaWRzID0gYXdhaXQgdGhpcy50cmFuc2FjdGlvbnMuc2VhcmNoKFwiU2lsby1OYW1lXCIsIHJlc291cmNlLmdldEFjY2Vzc0tleSgpKTtcbiAgICAgICAgaWYgKGlkcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkYXRhIGNvdWxkIGJlIGZvdW5kIGZvciB0aGUgU2lsbyBVUkk6ICR7c2lsb1VSSX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMudHJhbnNhY3Rpb25zLmdldChpZHNbMF0pO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRhdGEgY291bGQgYmUgZm91bmQgZm9yIHRoZSBTaWxvIFVSSTogJHtzaWxvVVJJfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IHRyYW5zYWN0aW9uLmdldChcImRhdGFcIiwgeyBkZWNvZGU6IHRydWUsIHN0cmluZzogZmFsc2UgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyeXB0by5kZWNyeXB0KGVuY3J5cHRlZCwgcmVzb3VyY2UuZ2V0RW5jcnlwdGlvbktleSgpKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFRyYW5zYWN0aW9uRGF0YSh0cmFuc2FjdGlvbiwgc2lsb1VSSSkge1xuICAgICAgICBpZiAoIXNpbG9VUkkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gU2lsbyBVUkkgc3BlY2lmaWVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBhd2FpdCB0aGlzLnBhcnNlVXJpKHNpbG9VUkkpO1xuICAgICAgICBjb25zdCBlbmNyeXB0ZWQgPSB0cmFuc2FjdGlvbi5nZXQoXCJkYXRhXCIsIHsgZGVjb2RlOiB0cnVlLCBzdHJpbmc6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG8uZGVjcnlwdChlbmNyeXB0ZWQsIHJlc291cmNlLmdldEVuY3J5cHRpb25LZXkoKSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlVXJpKHNpbG9VUkkpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gc2lsb1VSSS5tYXRjaCgvXihbYS16MC05LV9dKylcXC4oWzAtOV0rKS9pKTtcbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBTaWxvIG5hbWUsIG11c3QgYmUgYSBuYW1lIGluIHRoZSBmb3JtYXQgb2YgW2EtejAtOV0rLlswLTldKywgZS5nLiAnYnViYmxlLjcnYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lsb05hbWUgPSBwYXJzZWRbMV07XG4gICAgICAgIGNvbnN0IGhhc2hJdGVyYXRpb25zID0gTWF0aC5wb3coMiwgcGFyc2VJbnQocGFyc2VkWzJdKSk7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IGF3YWl0IHRoaXMuaGFzaChBcndlYXZlVXRpbHMuc3RyaW5nVG9CdWZmZXIoc2lsb05hbWUpLCBoYXNoSXRlcmF0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFjY2Vzc0tleSA9IEFyd2VhdmVVdGlscy5idWZmZXJUb2I2NChkaWdlc3Quc2xpY2UoMCwgMTUpKTtcbiAgICAgICAgY29uc3QgZW5jcnlwdGlvbmtleSA9IGF3YWl0IHRoaXMuaGFzaChkaWdlc3Quc2xpY2UoMTYsIDMxKSwgMSk7XG4gICAgICAgIHJldHVybiBuZXcgU2lsb1Jlc291cmNlKHNpbG9VUkksIGFjY2Vzc0tleSwgZW5jcnlwdGlvbmtleSk7XG4gICAgfVxuICAgIGFzeW5jIGhhc2goaW5wdXQsIGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgbGV0IGRpZ2VzdCA9IGF3YWl0IHRoaXMuY3J5cHRvLmhhc2goaW5wdXQpO1xuICAgICAgICBmb3IgKGxldCBjb3VudCA9IDA7IGNvdW50IDwgaXRlcmF0aW9ucyAtIDE7IGNvdW50KyspIHtcbiAgICAgICAgICAgIGRpZ2VzdCA9IGF3YWl0IHRoaXMuY3J5cHRvLmhhc2goZGlnZXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlnZXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNpbG87XG5jbGFzcyBTaWxvUmVzb3VyY2Uge1xuICAgIHVyaTtcbiAgICBhY2Nlc3NLZXk7XG4gICAgZW5jcnlwdGlvbktleTtcbiAgICBjb25zdHJ1Y3Rvcih1cmksIGFjY2Vzc0tleSwgZW5jcnlwdGlvbktleSkge1xuICAgICAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICAgICAgdGhpcy5hY2Nlc3NLZXkgPSBhY2Nlc3NLZXk7XG4gICAgICAgIHRoaXMuZW5jcnlwdGlvbktleSA9IGVuY3J5cHRpb25LZXk7XG4gICAgfVxuICAgIGdldFVyaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJpO1xuICAgIH1cbiAgICBnZXRBY2Nlc3NLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc0tleTtcbiAgICB9XG4gICAgZ2V0RW5jcnlwdGlvbktleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbktleTtcbiAgICB9XG59XG5leHBvcnRzLlNpbG9SZXNvdXJjZSA9IFNpbG9SZXNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbG8uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/silo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/transactions.js":
/*!***************************************************!*\
  !*** ./node_modules/arweave/node/transactions.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst error_1 = __importDefault(__webpack_require__(/*! ./lib/error */ \"(ssr)/./node_modules/arweave/node/lib/error.js\"));\nconst transaction_1 = __importDefault(__webpack_require__(/*! ./lib/transaction */ \"(ssr)/./node_modules/arweave/node/lib/transaction.js\"));\nconst ArweaveUtils = __importStar(__webpack_require__(/*! ./lib/utils */ \"(ssr)/./node_modules/arweave/node/lib/utils.js\"));\nconst transaction_uploader_1 = __webpack_require__(/*! ./lib/transaction-uploader */ \"(ssr)/./node_modules/arweave/node/lib/transaction-uploader.js\");\n__webpack_require__(/*! arconnect */ \"(ssr)/./node_modules/arconnect/index.es.js\");\nclass Transactions {\n    api;\n    crypto;\n    chunks;\n    constructor(api, crypto, chunks) {\n        this.api = api;\n        this.crypto = crypto;\n        this.chunks = chunks;\n    }\n    async getTransactionAnchor() {\n        const res = await this.api.get(`tx_anchor`);\n        if (!res.data.match(/^[a-z0-9_-]{43,}/i) || !res.ok) {\n            throw new Error(`Could not getTransactionAnchor. Received: ${res.data}. Status: ${res.status}, ${res.statusText}`);\n        }\n        return res.data;\n    }\n    async getPrice(byteSize, targetAddress) {\n        let endpoint = targetAddress\n            ? `price/${byteSize}/${targetAddress}`\n            : `price/${byteSize}`;\n        const res = await this.api.get(endpoint);\n        if (!/^\\d+$/.test(res.data) || !res.ok) {\n            throw new Error(`Could not getPrice. Received: ${res.data}. Status: ${res.status}, ${res.statusText}`);\n        }\n        return res.data;\n    }\n    async get(id) {\n        const response = await this.api.get(`tx/${id}`);\n        if (response.status == 200) {\n            const data_size = parseInt(response.data.data_size);\n            if (response.data.format >= 2 &&\n                data_size > 0 &&\n                data_size <= 1024 * 1024 * 12) {\n                const data = await this.getData(id);\n                return new transaction_1.default({\n                    ...response.data,\n                    data,\n                });\n            }\n            return new transaction_1.default({\n                ...response.data,\n                format: response.data.format || 1,\n            });\n        }\n        if (response.status == 404) {\n            throw new error_1.default(\"TX_NOT_FOUND\" /* ArweaveErrorType.TX_NOT_FOUND */);\n        }\n        if (response.status == 410) {\n            throw new error_1.default(\"TX_FAILED\" /* ArweaveErrorType.TX_FAILED */);\n        }\n        throw new error_1.default(\"TX_INVALID\" /* ArweaveErrorType.TX_INVALID */);\n    }\n    fromRaw(attributes) {\n        return new transaction_1.default(attributes);\n    }\n    /** @deprecated use GQL https://gql-guide.arweave.net */\n    async search(tagName, tagValue) {\n        return this.api\n            .post(`arql`, {\n            op: \"equals\",\n            expr1: tagName,\n            expr2: tagValue,\n        })\n            .then((response) => {\n            if (!response.data) {\n                return [];\n            }\n            return response.data;\n        });\n    }\n    getStatus(id) {\n        return this.api.get(`tx/${id}/status`).then((response) => {\n            if (response.status == 200) {\n                return {\n                    status: 200,\n                    confirmed: response.data,\n                };\n            }\n            return {\n                status: response.status,\n                confirmed: null,\n            };\n        });\n    }\n    async getData(id, options) {\n        let data = undefined;\n        try {\n            data = await this.chunks.downloadChunkedData(id);\n        }\n        catch (error) {\n            console.error(`Error while trying to download chunked data for ${id}`);\n            console.error(error);\n        }\n        if (!data) {\n            console.warn(`Falling back to gateway cache for ${id}`);\n            try {\n                const { data: resData, ok, status, statusText, } = await this.api.get(`/${id}`, { responseType: \"arraybuffer\" });\n                if (!ok) {\n                    throw new Error(`Bad http status code`, {\n                        cause: { status, statusText },\n                    });\n                }\n                data = resData;\n            }\n            catch (error) {\n                console.error(`Error while trying to download contiguous data from gateway cache for ${id}`);\n                console.error(error);\n            }\n        }\n        if (!data) {\n            throw new Error(`${id} data was not found!`);\n        }\n        if (options && options.decode && !options.string) {\n            return data;\n        }\n        if (options && options.decode && options.string) {\n            return ArweaveUtils.bufferToString(data);\n        }\n        // Since decode wasn't requested, caller expects b64url encoded data.\n        return ArweaveUtils.bufferTob64Url(data);\n    }\n    async sign(transaction, jwk, //\"use_wallet\" for backwards compatibility only\n    options) {\n        /** Non-exhaustive (only checks key names), but previously no jwk checking was done */\n        const isJwk = (obj) => {\n            let valid = true;\n            [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"].map((key) => !(key in obj) && (valid = false));\n            return valid;\n        };\n        const validJwk = typeof jwk === \"object\" && isJwk(jwk);\n        const externalWallet = typeof arweaveWallet === \"object\";\n        if (!validJwk && !externalWallet) {\n            throw new Error(`No valid JWK or external wallet found to sign transaction.`);\n        }\n        else if (validJwk) {\n            transaction.setOwner(jwk.n);\n            let dataToSign = await transaction.getSignatureData();\n            let rawSignature = await this.crypto.sign(jwk, dataToSign, options);\n            let id = await this.crypto.hash(rawSignature);\n            transaction.setSignature({\n                id: ArweaveUtils.bufferTob64Url(id),\n                owner: jwk.n,\n                signature: ArweaveUtils.bufferTob64Url(rawSignature),\n            });\n        }\n        else if (externalWallet) {\n            try {\n                const existingPermissions = await arweaveWallet.getPermissions();\n                if (!existingPermissions.includes(\"SIGN_TRANSACTION\"))\n                    await arweaveWallet.connect([\"SIGN_TRANSACTION\"]);\n            }\n            catch {\n                // Permission is already granted\n            }\n            const signedTransaction = await arweaveWallet.sign(transaction, options);\n            transaction.setSignature({\n                id: signedTransaction.id,\n                owner: signedTransaction.owner,\n                reward: signedTransaction.reward,\n                tags: signedTransaction.tags,\n                signature: signedTransaction.signature,\n            });\n        }\n        else {\n            //can't get here, but for sanity we'll throw an error.\n            throw new Error(`An error occurred while signing. Check wallet is valid`);\n        }\n    }\n    async verify(transaction) {\n        const signaturePayload = await transaction.getSignatureData();\n        /**\n         * The transaction ID should be a SHA-256 hash of the raw signature bytes, so this needs\n         * to be recalculated from the signature and checked against the transaction ID.\n         */\n        const rawSignature = transaction.get(\"signature\", {\n            decode: true,\n            string: false,\n        });\n        const expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));\n        if (transaction.id !== expectedId) {\n            throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);\n        }\n        /**\n         * Now verify the signature is valid and signed by the owner wallet (owner field = originating wallet public key).\n         */\n        return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);\n    }\n    async post(transaction) {\n        if (typeof transaction === \"string\") {\n            transaction = new transaction_1.default(JSON.parse(transaction));\n        }\n        else if (typeof transaction.readInt32BE === \"function\") {\n            transaction = new transaction_1.default(JSON.parse(transaction.toString()));\n        }\n        else if (typeof transaction === \"object\" &&\n            !(transaction instanceof transaction_1.default)) {\n            transaction = new transaction_1.default(transaction);\n        }\n        if (!(transaction instanceof transaction_1.default)) {\n            throw new Error(`Must be Transaction object`);\n        }\n        if (!transaction.chunks) {\n            await transaction.prepareChunks(transaction.data);\n        }\n        const uploader = await this.getUploader(transaction, transaction.data);\n        // Emulate existing error & return value behavior.\n        try {\n            while (!uploader.isComplete) {\n                await uploader.uploadChunk();\n            }\n        }\n        catch (e) {\n            if (uploader.lastResponseStatus > 0) {\n                return {\n                    status: uploader.lastResponseStatus,\n                    statusText: uploader.lastResponseError,\n                    data: {\n                        error: uploader.lastResponseError,\n                    },\n                };\n            }\n            throw e;\n        }\n        return {\n            status: 200,\n            statusText: \"OK\",\n            data: {},\n        };\n    }\n    /**\n     * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress\n     * and the ability to resume.\n     *\n     * Usage example:\n     *\n     * ```\n     * const uploader = arweave.transactions.getUploader(transaction);\n     * while (!uploader.isComplete) {\n     *   await uploader.uploadChunk();\n     *   console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save progress object, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n    async getUploader(upload, data) {\n        let uploader;\n        if (data instanceof ArrayBuffer) {\n            data = new Uint8Array(data);\n        }\n        if (upload instanceof transaction_1.default) {\n            if (!data) {\n                data = upload.data;\n            }\n            if (!(data instanceof Uint8Array)) {\n                throw new Error(\"Data format is invalid\");\n            }\n            if (!upload.chunks) {\n                await upload.prepareChunks(data);\n            }\n            uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);\n            if (!uploader.data || uploader.data.length === 0) {\n                uploader.data = data;\n            }\n        }\n        else {\n            if (typeof upload === \"string\") {\n                upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);\n            }\n            if (!data || !(data instanceof Uint8Array)) {\n                throw new Error(`Must provide data when resuming upload`);\n            }\n            // upload should be a serialized upload.\n            uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);\n        }\n        return uploader;\n    }\n    /**\n     * Async generator version of uploader\n     *\n     * Usage example:\n     *\n     * ```\n     * for await (const uploader of arweave.transactions.upload(tx)) {\n     *  console.log(`${uploader.pctComplete}%`);\n     * }\n     * ```\n     *\n     * @param upload a Transaction object, a previously save uploader, or a transaction id.\n     * @param data the data of the transaction. Required when resuming an upload.\n     */\n    async *upload(upload, data) {\n        const uploader = await this.getUploader(upload, data);\n        while (!uploader.isComplete) {\n            await uploader.uploadChunk();\n            yield uploader;\n        }\n        return uploader;\n    }\n}\nexports[\"default\"] = Transactions;\n//# sourceMappingURL=transactions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL3RyYW5zYWN0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsbUJBQU8sQ0FBQyxtRUFBYTtBQUNyRCxzQ0FBc0MsbUJBQU8sQ0FBQywrRUFBbUI7QUFDakUsa0NBQWtDLG1CQUFPLENBQUMsbUVBQWE7QUFDdkQsK0JBQStCLG1CQUFPLENBQUMsaUdBQTRCO0FBQ25FLG1CQUFPLENBQUMsNkRBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDLHlFQUF5RSxTQUFTLFlBQVksV0FBVyxJQUFJLGVBQWU7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTLEdBQUcsY0FBYztBQUNqRCx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsNkRBQTZELFNBQVMsWUFBWSxXQUFXLElBQUksZUFBZTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxHQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxHQUFHO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxHQUFHO0FBQ2pFO0FBQ0Esd0JBQXdCLHlDQUF5Qyx5QkFBeUIsR0FBRyxLQUFLLDZCQUE2QjtBQUMvSDtBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQjtBQUNyRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsR0FBRztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy93YWxpL0Rvd25sb2Fkcy9yb3VsZXR0ZSAvbm9kZV9tb2R1bGVzL2Fyd2VhdmUvbm9kZS90cmFuc2FjdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGVycm9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGliL2Vycm9yXCIpKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGliL3RyYW5zYWN0aW9uXCIpKTtcbmNvbnN0IEFyd2VhdmVVdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvdXRpbHNcIikpO1xuY29uc3QgdHJhbnNhY3Rpb25fdXBsb2FkZXJfMSA9IHJlcXVpcmUoXCIuL2xpYi90cmFuc2FjdGlvbi11cGxvYWRlclwiKTtcbnJlcXVpcmUoXCJhcmNvbm5lY3RcIik7XG5jbGFzcyBUcmFuc2FjdGlvbnMge1xuICAgIGFwaTtcbiAgICBjcnlwdG87XG4gICAgY2h1bmtzO1xuICAgIGNvbnN0cnVjdG9yKGFwaSwgY3J5cHRvLCBjaHVua3MpIHtcbiAgICAgICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgICAgIHRoaXMuY3J5cHRvID0gY3J5cHRvO1xuICAgICAgICB0aGlzLmNodW5rcyA9IGNodW5rcztcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25BbmNob3IoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuYXBpLmdldChgdHhfYW5jaG9yYCk7XG4gICAgICAgIGlmICghcmVzLmRhdGEubWF0Y2goL15bYS16MC05Xy1dezQzLH0vaSkgfHwgIXJlcy5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0VHJhbnNhY3Rpb25BbmNob3IuIFJlY2VpdmVkOiAke3Jlcy5kYXRhfS4gU3RhdHVzOiAke3Jlcy5zdGF0dXN9LCAke3Jlcy5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXMuZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJpY2UoYnl0ZVNpemUsIHRhcmdldEFkZHJlc3MpIHtcbiAgICAgICAgbGV0IGVuZHBvaW50ID0gdGFyZ2V0QWRkcmVzc1xuICAgICAgICAgICAgPyBgcHJpY2UvJHtieXRlU2l6ZX0vJHt0YXJnZXRBZGRyZXNzfWBcbiAgICAgICAgICAgIDogYHByaWNlLyR7Ynl0ZVNpemV9YDtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5hcGkuZ2V0KGVuZHBvaW50KTtcbiAgICAgICAgaWYgKCEvXlxcZCskLy50ZXN0KHJlcy5kYXRhKSB8fCAhcmVzLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBnZXRQcmljZS4gUmVjZWl2ZWQ6ICR7cmVzLmRhdGF9LiBTdGF0dXM6ICR7cmVzLnN0YXR1c30sICR7cmVzLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgIH1cbiAgICBhc3luYyBnZXQoaWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaS5nZXQoYHR4LyR7aWR9YCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhX3NpemUgPSBwYXJzZUludChyZXNwb25zZS5kYXRhLmRhdGFfc2l6ZSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5mb3JtYXQgPj0gMiAmJlxuICAgICAgICAgICAgICAgIGRhdGFfc2l6ZSA+IDAgJiZcbiAgICAgICAgICAgICAgICBkYXRhX3NpemUgPD0gMTAyNCAqIDEwMjQgKiAxMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdldERhdGEoaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdHJhbnNhY3Rpb25fMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgdHJhbnNhY3Rpb25fMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogcmVzcG9uc2UuZGF0YS5mb3JtYXQgfHwgMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT0gNDA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5kZWZhdWx0KFwiVFhfTk9UX0ZPVU5EXCIgLyogQXJ3ZWF2ZUVycm9yVHlwZS5UWF9OT1RfRk9VTkQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT0gNDEwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5kZWZhdWx0KFwiVFhfRkFJTEVEXCIgLyogQXJ3ZWF2ZUVycm9yVHlwZS5UWF9GQUlMRUQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcl8xLmRlZmF1bHQoXCJUWF9JTlZBTElEXCIgLyogQXJ3ZWF2ZUVycm9yVHlwZS5UWF9JTlZBTElEICovKTtcbiAgICB9XG4gICAgZnJvbVJhdyhhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHJhbnNhY3Rpb25fMS5kZWZhdWx0KGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIEdRTCBodHRwczovL2dxbC1ndWlkZS5hcndlYXZlLm5ldCAqL1xuICAgIGFzeW5jIHNlYXJjaCh0YWdOYW1lLCB0YWdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGlcbiAgICAgICAgICAgIC5wb3N0KGBhcnFsYCwge1xuICAgICAgICAgICAgb3A6IFwiZXF1YWxzXCIsXG4gICAgICAgICAgICBleHByMTogdGFnTmFtZSxcbiAgICAgICAgICAgIGV4cHIyOiB0YWdWYWx1ZSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRTdGF0dXMoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmdldChgdHgvJHtpZH0vc3RhdHVzYCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1lZDogcmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBjb25maXJtZWQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGF0YShpZCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBhd2FpdCB0aGlzLmNodW5rcy5kb3dubG9hZENodW5rZWREYXRhKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoaWxlIHRyeWluZyB0byBkb3dubG9hZCBjaHVua2VkIGRhdGEgZm9yICR7aWR9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFsbGluZyBiYWNrIHRvIGdhdGV3YXkgY2FjaGUgZm9yICR7aWR9YCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVzRGF0YSwgb2ssIHN0YXR1cywgc3RhdHVzVGV4dCwgfSA9IGF3YWl0IHRoaXMuYXBpLmdldChgLyR7aWR9YCwgeyByZXNwb25zZVR5cGU6IFwiYXJyYXlidWZmZXJcIiB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIGh0dHAgc3RhdHVzIGNvZGVgLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogeyBzdGF0dXMsIHN0YXR1c1RleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEgPSByZXNEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGRvd25sb2FkIGNvbnRpZ3VvdXMgZGF0YSBmcm9tIGdhdGV3YXkgY2FjaGUgZm9yICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7aWR9IGRhdGEgd2FzIG5vdCBmb3VuZCFgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlY29kZSAmJiAhb3B0aW9ucy5zdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVjb2RlICYmIG9wdGlvbnMuc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJ3ZWF2ZVV0aWxzLmJ1ZmZlclRvU3RyaW5nKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIGRlY29kZSB3YXNuJ3QgcmVxdWVzdGVkLCBjYWxsZXIgZXhwZWN0cyBiNjR1cmwgZW5jb2RlZCBkYXRhLlxuICAgICAgICByZXR1cm4gQXJ3ZWF2ZVV0aWxzLmJ1ZmZlclRvYjY0VXJsKGRhdGEpO1xuICAgIH1cbiAgICBhc3luYyBzaWduKHRyYW5zYWN0aW9uLCBqd2ssIC8vXCJ1c2Vfd2FsbGV0XCIgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IG9ubHlcbiAgICBvcHRpb25zKSB7XG4gICAgICAgIC8qKiBOb24tZXhoYXVzdGl2ZSAob25seSBjaGVja3Mga2V5IG5hbWVzKSwgYnV0IHByZXZpb3VzbHkgbm8gandrIGNoZWNraW5nIHdhcyBkb25lICovXG4gICAgICAgIGNvbnN0IGlzSndrID0gKG9iaikgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIFtcIm5cIiwgXCJlXCIsIFwiZFwiLCBcInBcIiwgXCJxXCIsIFwiZHBcIiwgXCJkcVwiLCBcInFpXCJdLm1hcCgoa2V5KSA9PiAhKGtleSBpbiBvYmopICYmICh2YWxpZCA9IGZhbHNlKSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbGlkSndrID0gdHlwZW9mIGp3ayA9PT0gXCJvYmplY3RcIiAmJiBpc0p3ayhqd2spO1xuICAgICAgICBjb25zdCBleHRlcm5hbFdhbGxldCA9IHR5cGVvZiBhcndlYXZlV2FsbGV0ID09PSBcIm9iamVjdFwiO1xuICAgICAgICBpZiAoIXZhbGlkSndrICYmICFleHRlcm5hbFdhbGxldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB2YWxpZCBKV0sgb3IgZXh0ZXJuYWwgd2FsbGV0IGZvdW5kIHRvIHNpZ24gdHJhbnNhY3Rpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsaWRKd2spIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnNldE93bmVyKGp3ay5uKTtcbiAgICAgICAgICAgIGxldCBkYXRhVG9TaWduID0gYXdhaXQgdHJhbnNhY3Rpb24uZ2V0U2lnbmF0dXJlRGF0YSgpO1xuICAgICAgICAgICAgbGV0IHJhd1NpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY3J5cHRvLnNpZ24oandrLCBkYXRhVG9TaWduLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGxldCBpZCA9IGF3YWl0IHRoaXMuY3J5cHRvLmhhc2gocmF3U2lnbmF0dXJlKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnNldFNpZ25hdHVyZSh7XG4gICAgICAgICAgICAgICAgaWQ6IEFyd2VhdmVVdGlscy5idWZmZXJUb2I2NFVybChpZCksXG4gICAgICAgICAgICAgICAgb3duZXI6IGp3ay5uLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogQXJ3ZWF2ZVV0aWxzLmJ1ZmZlclRvYjY0VXJsKHJhd1NpZ25hdHVyZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHRlcm5hbFdhbGxldCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1Blcm1pc3Npb25zID0gYXdhaXQgYXJ3ZWF2ZVdhbGxldC5nZXRQZXJtaXNzaW9ucygpO1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdQZXJtaXNzaW9ucy5pbmNsdWRlcyhcIlNJR05fVFJBTlNBQ1RJT05cIikpXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGFyd2VhdmVXYWxsZXQuY29ubmVjdChbXCJTSUdOX1RSQU5TQUNUSU9OXCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAvLyBQZXJtaXNzaW9uIGlzIGFscmVhZHkgZ3JhbnRlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCBhcndlYXZlV2FsbGV0LnNpZ24odHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uc2V0U2lnbmF0dXJlKHtcbiAgICAgICAgICAgICAgICBpZDogc2lnbmVkVHJhbnNhY3Rpb24uaWQsXG4gICAgICAgICAgICAgICAgb3duZXI6IHNpZ25lZFRyYW5zYWN0aW9uLm93bmVyLFxuICAgICAgICAgICAgICAgIHJld2FyZDogc2lnbmVkVHJhbnNhY3Rpb24ucmV3YXJkLFxuICAgICAgICAgICAgICAgIHRhZ3M6IHNpZ25lZFRyYW5zYWN0aW9uLnRhZ3MsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduZWRUcmFuc2FjdGlvbi5zaWduYXR1cmUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vY2FuJ3QgZ2V0IGhlcmUsIGJ1dCBmb3Igc2FuaXR5IHdlJ2xsIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBzaWduaW5nLiBDaGVjayB3YWxsZXQgaXMgdmFsaWRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB2ZXJpZnkodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlUGF5bG9hZCA9IGF3YWl0IHRyYW5zYWN0aW9uLmdldFNpZ25hdHVyZURhdGEoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0cmFuc2FjdGlvbiBJRCBzaG91bGQgYmUgYSBTSEEtMjU2IGhhc2ggb2YgdGhlIHJhdyBzaWduYXR1cmUgYnl0ZXMsIHNvIHRoaXMgbmVlZHNcbiAgICAgICAgICogdG8gYmUgcmVjYWxjdWxhdGVkIGZyb20gdGhlIHNpZ25hdHVyZSBhbmQgY2hlY2tlZCBhZ2FpbnN0IHRoZSB0cmFuc2FjdGlvbiBJRC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJhd1NpZ25hdHVyZSA9IHRyYW5zYWN0aW9uLmdldChcInNpZ25hdHVyZVwiLCB7XG4gICAgICAgICAgICBkZWNvZGU6IHRydWUsXG4gICAgICAgICAgICBzdHJpbmc6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRJZCA9IEFyd2VhdmVVdGlscy5idWZmZXJUb2I2NFVybChhd2FpdCB0aGlzLmNyeXB0by5oYXNoKHJhd1NpZ25hdHVyZSkpO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uaWQgIT09IGV4cGVjdGVkSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0cmFuc2FjdGlvbiBzaWduYXR1cmUgb3IgSUQhIFRoZSB0cmFuc2FjdGlvbiBJRCBkb2Vzbid0IG1hdGNoIHRoZSBleHBlY3RlZCBTSEEtMjU2IGhhc2ggb2YgdGhlIHNpZ25hdHVyZS5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm93IHZlcmlmeSB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkIGFuZCBzaWduZWQgYnkgdGhlIG93bmVyIHdhbGxldCAob3duZXIgZmllbGQgPSBvcmlnaW5hdGluZyB3YWxsZXQgcHVibGljIGtleSkuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gdGhpcy5jcnlwdG8udmVyaWZ5KHRyYW5zYWN0aW9uLm93bmVyLCBzaWduYXR1cmVQYXlsb2FkLCByYXdTaWduYXR1cmUpO1xuICAgIH1cbiAgICBhc3luYyBwb3N0KHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gbmV3IHRyYW5zYWN0aW9uXzEuZGVmYXVsdChKU09OLnBhcnNlKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLnJlYWRJbnQzMkJFID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gbmV3IHRyYW5zYWN0aW9uXzEuZGVmYXVsdChKU09OLnBhcnNlKHRyYW5zYWN0aW9uLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbl8xLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLmRlZmF1bHQodHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25fMS5kZWZhdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdXN0IGJlIFRyYW5zYWN0aW9uIG9iamVjdGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uY2h1bmtzKSB7XG4gICAgICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5wcmVwYXJlQ2h1bmtzKHRyYW5zYWN0aW9uLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwbG9hZGVyID0gYXdhaXQgdGhpcy5nZXRVcGxvYWRlcih0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZGF0YSk7XG4gICAgICAgIC8vIEVtdWxhdGUgZXhpc3RpbmcgZXJyb3IgJiByZXR1cm4gdmFsdWUgYmVoYXZpb3IuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAoIXVwbG9hZGVyLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB1cGxvYWRlci51cGxvYWRDaHVuaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAodXBsb2FkZXIubGFzdFJlc3BvbnNlU3RhdHVzID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogdXBsb2FkZXIubGFzdFJlc3BvbnNlU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB1cGxvYWRlci5sYXN0UmVzcG9uc2VFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHVwbG9hZGVyLmxhc3RSZXNwb25zZUVycm9yLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IFwiT0tcIixcbiAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuIHVwbG9hZGVyIHRoYW4gY2FuIGJlIHVzZWQgdG8gdXBsb2FkIGEgdHJhbnNhY3Rpb24gY2h1bmsgYnkgY2h1bmssIGdpdmluZyBwcm9ncmVzc1xuICAgICAqIGFuZCB0aGUgYWJpbGl0eSB0byByZXN1bWUuXG4gICAgICpcbiAgICAgKiBVc2FnZSBleGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgdXBsb2FkZXIgPSBhcndlYXZlLnRyYW5zYWN0aW9ucy5nZXRVcGxvYWRlcih0cmFuc2FjdGlvbik7XG4gICAgICogd2hpbGUgKCF1cGxvYWRlci5pc0NvbXBsZXRlKSB7XG4gICAgICogICBhd2FpdCB1cGxvYWRlci51cGxvYWRDaHVuaygpO1xuICAgICAqICAgY29uc29sZS5sb2coYCR7dXBsb2FkZXIucGN0Q29tcGxldGV9JWApO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cGxvYWQgYSBUcmFuc2FjdGlvbiBvYmplY3QsIGEgcHJldmlvdXNseSBzYXZlIHByb2dyZXNzIG9iamVjdCwgb3IgYSB0cmFuc2FjdGlvbiBpZC5cbiAgICAgKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBvZiB0aGUgdHJhbnNhY3Rpb24uIFJlcXVpcmVkIHdoZW4gcmVzdW1pbmcgYW4gdXBsb2FkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVwbG9hZGVyKHVwbG9hZCwgZGF0YSkge1xuICAgICAgICBsZXQgdXBsb2FkZXI7XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBsb2FkIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25fMS5kZWZhdWx0KSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdXBsb2FkLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIGZvcm1hdCBpcyBpbnZhbGlkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1cGxvYWQuY2h1bmtzKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXBsb2FkLnByZXBhcmVDaHVua3MoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGxvYWRlciA9IG5ldyB0cmFuc2FjdGlvbl91cGxvYWRlcl8xLlRyYW5zYWN0aW9uVXBsb2FkZXIodGhpcy5hcGksIHVwbG9hZCk7XG4gICAgICAgICAgICBpZiAoIXVwbG9hZGVyLmRhdGEgfHwgdXBsb2FkZXIuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB1cGxvYWRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXBsb2FkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdXBsb2FkID0gYXdhaXQgdHJhbnNhY3Rpb25fdXBsb2FkZXJfMS5UcmFuc2FjdGlvblVwbG9hZGVyLmZyb21UcmFuc2FjdGlvbklkKHRoaXMuYXBpLCB1cGxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdXN0IHByb3ZpZGUgZGF0YSB3aGVuIHJlc3VtaW5nIHVwbG9hZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXBsb2FkIHNob3VsZCBiZSBhIHNlcmlhbGl6ZWQgdXBsb2FkLlxuICAgICAgICAgICAgdXBsb2FkZXIgPSBhd2FpdCB0cmFuc2FjdGlvbl91cGxvYWRlcl8xLlRyYW5zYWN0aW9uVXBsb2FkZXIuZnJvbVNlcmlhbGl6ZWQodGhpcy5hcGksIHVwbG9hZCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3luYyBnZW5lcmF0b3IgdmVyc2lvbiBvZiB1cGxvYWRlclxuICAgICAqXG4gICAgICogVXNhZ2UgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGZvciBhd2FpdCAoY29uc3QgdXBsb2FkZXIgb2YgYXJ3ZWF2ZS50cmFuc2FjdGlvbnMudXBsb2FkKHR4KSkge1xuICAgICAqICBjb25zb2xlLmxvZyhgJHt1cGxvYWRlci5wY3RDb21wbGV0ZX0lYCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHVwbG9hZCBhIFRyYW5zYWN0aW9uIG9iamVjdCwgYSBwcmV2aW91c2x5IHNhdmUgdXBsb2FkZXIsIG9yIGEgdHJhbnNhY3Rpb24gaWQuXG4gICAgICogQHBhcmFtIGRhdGEgdGhlIGRhdGEgb2YgdGhlIHRyYW5zYWN0aW9uLiBSZXF1aXJlZCB3aGVuIHJlc3VtaW5nIGFuIHVwbG9hZC5cbiAgICAgKi9cbiAgICBhc3luYyAqdXBsb2FkKHVwbG9hZCwgZGF0YSkge1xuICAgICAgICBjb25zdCB1cGxvYWRlciA9IGF3YWl0IHRoaXMuZ2V0VXBsb2FkZXIodXBsb2FkLCBkYXRhKTtcbiAgICAgICAgd2hpbGUgKCF1cGxvYWRlci5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICBhd2FpdCB1cGxvYWRlci51cGxvYWRDaHVuaygpO1xuICAgICAgICAgICAgeWllbGQgdXBsb2FkZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFRyYW5zYWN0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/transactions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/arweave/node/wallets.js":
/*!**********************************************!*\
  !*** ./node_modules/arweave/node/wallets.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ArweaveUtils = __importStar(__webpack_require__(/*! ./lib/utils */ \"(ssr)/./node_modules/arweave/node/lib/utils.js\"));\n__webpack_require__(/*! arconnect */ \"(ssr)/./node_modules/arconnect/index.es.js\");\nclass Wallets {\n    api;\n    crypto;\n    constructor(api, crypto) {\n        this.api = api;\n        this.crypto = crypto;\n    }\n    /**\n     * Get the wallet balance for the given address.\n     *\n     * @param {string} address - The arweave address to get the balance for.\n     *\n     * @returns {Promise<string>} - Promise which resolves with a winston string balance.\n     */\n    getBalance(address) {\n        return this.api.get(`wallet/${address}/balance`).then((response) => {\n            return response.data;\n        });\n    }\n    /**\n     * Get the last transaction ID for the given wallet address.\n     *\n     * @param {string} address - The arweave address to get the transaction for.\n     *\n     * @returns {Promise<string>} - Promise which resolves with a transaction ID.\n     */\n    getLastTransactionID(address) {\n        return this.api.get(`wallet/${address}/last_tx`).then((response) => {\n            return response.data;\n        });\n    }\n    generate() {\n        return this.crypto.generateJWK();\n    }\n    async jwkToAddress(jwk) {\n        if (!jwk || jwk === \"use_wallet\") {\n            return this.getAddress();\n        }\n        else {\n            return this.getAddress(jwk);\n        }\n    }\n    async getAddress(jwk) {\n        if (!jwk || jwk === \"use_wallet\") {\n            try {\n                // @ts-ignore\n                await arweaveWallet.connect([\"ACCESS_ADDRESS\"]);\n            }\n            catch {\n                // Permission is already granted\n            }\n            // @ts-ignore\n            return arweaveWallet.getActiveAddress();\n        }\n        else {\n            return this.ownerToAddress(jwk.n);\n        }\n    }\n    async ownerToAddress(owner) {\n        return ArweaveUtils.bufferTob64Url(await this.crypto.hash(ArweaveUtils.b64UrlToBuffer(owner)));\n    }\n}\nexports[\"default\"] = Wallets;\n//# sourceMappingURL=wallets.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXJ3ZWF2ZS9ub2RlL3dhbGxldHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxtQkFBTyxDQUFDLG1FQUFhO0FBQ3ZELG1CQUFPLENBQUMsNkRBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvd2FsaS9Eb3dubG9hZHMvcm91bGV0dGUgL25vZGVfbW9kdWxlcy9hcndlYXZlL25vZGUvd2FsbGV0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXJ3ZWF2ZVV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2xpYi91dGlsc1wiKSk7XG5yZXF1aXJlKFwiYXJjb25uZWN0XCIpO1xuY2xhc3MgV2FsbGV0cyB7XG4gICAgYXBpO1xuICAgIGNyeXB0bztcbiAgICBjb25zdHJ1Y3RvcihhcGksIGNyeXB0bykge1xuICAgICAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICAgICAgdGhpcy5jcnlwdG8gPSBjcnlwdG87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgd2FsbGV0IGJhbGFuY2UgZm9yIHRoZSBnaXZlbiBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYXJ3ZWF2ZSBhZGRyZXNzIHRvIGdldCB0aGUgYmFsYW5jZSBmb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCBhIHdpbnN0b24gc3RyaW5nIGJhbGFuY2UuXG4gICAgICovXG4gICAgZ2V0QmFsYW5jZShhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5nZXQoYHdhbGxldC8ke2FkZHJlc3N9L2JhbGFuY2VgKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxhc3QgdHJhbnNhY3Rpb24gSUQgZm9yIHRoZSBnaXZlbiB3YWxsZXQgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFyd2VhdmUgYWRkcmVzcyB0byBnZXQgdGhlIHRyYW5zYWN0aW9uIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gUHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIGEgdHJhbnNhY3Rpb24gSUQuXG4gICAgICovXG4gICAgZ2V0TGFzdFRyYW5zYWN0aW9uSUQoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGkuZ2V0KGB3YWxsZXQvJHthZGRyZXNzfS9sYXN0X3R4YCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2VuZXJhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyeXB0by5nZW5lcmF0ZUpXSygpO1xuICAgIH1cbiAgICBhc3luYyBqd2tUb0FkZHJlc3MoandrKSB7XG4gICAgICAgIGlmICghandrIHx8IGp3ayA9PT0gXCJ1c2Vfd2FsbGV0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFkZHJlc3MoandrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRBZGRyZXNzKGp3aykge1xuICAgICAgICBpZiAoIWp3ayB8fCBqd2sgPT09IFwidXNlX3dhbGxldFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBhd2FpdCBhcndlYXZlV2FsbGV0LmNvbm5lY3QoW1wiQUNDRVNTX0FERFJFU1NcIl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIFBlcm1pc3Npb24gaXMgYWxyZWFkeSBncmFudGVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gYXJ3ZWF2ZVdhbGxldC5nZXRBY3RpdmVBZGRyZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vd25lclRvQWRkcmVzcyhqd2subik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb3duZXJUb0FkZHJlc3Mob3duZXIpIHtcbiAgICAgICAgcmV0dXJuIEFyd2VhdmVVdGlscy5idWZmZXJUb2I2NFVybChhd2FpdCB0aGlzLmNyeXB0by5oYXNoKEFyd2VhdmVVdGlscy5iNjRVcmxUb0J1ZmZlcihvd25lcikpKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBXYWxsZXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/arweave/node/wallets.js\n");

/***/ })

};
;